<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- PWA: Web App Manifest -->
    <link rel="manifest" href="/manifest.json">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <link rel="stylesheet" href="https://unpkg.com/@phosphor-icons/web@2.1.1/src/fill/style.css" />
    <meta name="robots" content="noindex, nofollow">
    <title>Lyftiv - Suivi SÃ©ance Musculation</title>
    
    <style>
        /* CSS Variables for theme and color management (Pastel & Zen Lyftiv Theme) */
        :root {
            /* Background colors - soft, airy blues */
            --bg-grad-start: hsl(200, 60%, 95%);
            --bg-grad-end: hsl(220, 70%, 98%);
            
            /* Container & text colors - muted, friendly tones */
            --container-bg: hsla(0, 0%, 100%, 0.95);
            --text-color: hsl(220, 15%, 30%);
            --header-color: hsl(220, 20%, 20%);
            --sub-header-color: hsl(220, 10%, 45%);
            --border-color: hsl(210, 15%, 90%);
            --row-bg-even: hsla(210, 15%, 98%, 0.7);
            --input-bg: white;
            
            /* Primary buttons - gentle blue/purple gradient (for main actions) */
            --primary-grad-start: hsl(220, 60%, 70%);
            --primary-grad-end: hsl(240, 70%, 75%);
            --primary-color: hsl(220, 60%, 50%);

            /* Success (Green) - soft, natural greens (for affirmative actions) */
            --success-grad-start: hsl(140, 60%, 70%);
            --success-grad-end: hsl(160, 70%, 75%);
            --success-color: hsl(140, 50%, 45%);
            
            /* Warning (Orange) - soft, warm oranges (for secondary/neutral actions) */
            --warning-grad-start: hsl(40, 80%, 75%);
            --warning-grad-end: hsl(30, 90%, 80%);
            --warning-color: hsl(40, 70%, 50%);
            
            /* Danger (Red) - muted, earthy reds/pinks (for destructive actions) */
            --danger-grad-start: hsl(0, 60%, 75%);
            --danger-grad-end: hsl(10, 70%, 80%);
            --danger-color: hsl(0, 60%, 50%);
            
            /* Info (Blue) - soft, light blues (for informational/utility actions) */
            --info-grad-start: hsl(200, 70%, 70%);
            --info-grad-end: hsl(210, 80%, 75%);
            --info-color: hsl(200, 60%, 50%);

            --text-on-color: hsl(0, 0%, 100%); /* White text on colored backgrounds for readability */
            --shadow-light: hsla(220, 20%, 20%, 0.04);
            --shadow-medium: hsla(220, 20%, 20%, 0.08);
            --shadow-strong: hsla(220, 20%, 20%, 0.15);

            --border-radius-xs: 6px;
            --border-radius-base: 12px;
            --border-radius-medium: 18px;
            --border-radius-large: 24px;
            --border-radius-button: 30px;
            --spacing-xxs: 0.125rem; /* 2px */
            --spacing-xs: 0.25rem;
            --spacing-sm: 0.5rem;
            --spacing-md: 1rem;
            --spacing-lg: 1.5rem;
            --spacing-xl: 2rem;
            --spacing-xxl: 3rem;
            --spacing-xxxl: 4rem;
        }

        body.dark-mode {
            /* Background colors - deep, muted blues */
            --bg-grad-start: hsl(230, 20%, 18%);
            --bg-grad-end: hsl(245, 25%, 22%);
            
            /* Container & text colors - light, contrasting tones */
            --container-bg: hsla(220, 20%, 25%, 0.95);
            --text-color: hsl(210, 15%, 80%);
            --header-color: hsl(210, 10%, 75%);
            --sub-header-color: hsl(210, 10%, 60%);
            --border-color: hsl(220, 15%, 35%);
            --row-bg-even: hsla(220, 20%, 20%, 0.7);
            --input-bg: hsl(220, 20%, 20%);
            
            /* Primary buttons (dark mode) - muted, deeper versions */
            --primary-grad-start: hsl(220, 30%, 40%);
            --primary-grad-end: hsl(240, 35%, 45%);
            --primary-color: hsl(220, 60%, 65%);
            
            /* Success (dark mode) - muted, deeper versions */
            --success-grad-start: hsl(140, 30%, 40%);
            --success-grad-end: hsl(160, 35%, 45%);
            --success-color: hsl(140, 50%, 60%);
            
            /* Warning (dark mode) - muted, deeper versions */
            --warning-grad-start: hsl(40, 45%, 50%);
            --warning-grad-end: hsl(30, 50%, 55%);
            --warning-color: hsl(40, 70%, 65%);
            
            /* Danger (dark mode) - muted, deeper versions */
            --danger-grad-start: hsl(0, 35%, 45%);
            --danger-grad-end: hsl(10, 40%, 50%);
            --danger-color: hsl(0, 60%, 65%);
            
            /* Info (dark mode) - muted, deeper versions */
            --info-grad-start: hsl(200, 45%, 50%);
            --info-grad-end: hsl(210, 50%, 55%);
            --info-color: hsl(200, 60%, 65%);

            --text-on-color: hsl(0, 0%, 90%);
            --shadow-light: hsla(220, 20%, 10%, 0.2);
            --shadow-medium: hsla(220, 20%, 10%, 0.3);
            --shadow-strong: hsla(220, 20%, 10%, 0.4);
        }

        /* General styles */
        * { box-sizing: border-box; }
        html { scroll-behavior: smooth; }
        body {
            font-family: 'Inter', sans-serif;
            font-size: 16px; 
            line-height: 1.6; 
            margin: 0;
            padding: var(--spacing-xxl);
            background: linear-gradient(135deg, var(--bg-grad-start) 0%, var(--bg-grad-end) 100%);
            min-height: 100vh;
            color: var(--text-color);
            transition: background 0.6s ease, color 0.6s ease;
        }
        .main-container {
            max-width: 1600px;
            margin: 0 auto;
            background: var(--container-bg);
            border-radius: var(--border-radius-large);
            padding: var(--spacing-xxl);
            box-shadow: 0 15px 30px var(--shadow-medium);
            backdrop-filter: blur(10px);
            transition: background 0.5s ease;
            position: relative;
        }
        h2 {
            text-align: center;
            color: var(--header-color);
            margin-bottom: var(--spacing-xxl);
            font-size: 2.75rem;
            font-weight: 800;
            letter-spacing: -0.03em;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: var(--spacing-md);
        }
        .lyftiv-logo {
            width: 52px;
            height: 52px;
        }
        h3 {
            font-weight: 700;
            font-size: 1.4rem;
            color: var(--header-color);
            margin-bottom: var(--spacing-sm);
            letter-spacing: -0.01em;
        }
        h4 {
            margin: 0 0 var(--spacing-xs) 0;
            font-size: 1.15rem;
            color: var(--sub-header-color);
        }
        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: var(--spacing-lg);
            align-items: center;
            margin-bottom: var(--spacing-xl);
            padding: var(--spacing-lg);
            background: hsla(0, 0%, 100%, 0.1);
            border-radius: var(--border-radius-large);
            box-shadow: 0 3px 8px var(--shadow-light);
            transition: background 0.5s ease;
        }
        select, input[type="number"], input[type="text"], textarea {
            padding: var(--spacing-sm) var(--spacing-md);
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius-base);
            font-size: 1rem;
            background-color: var(--input-bg);
            color: var(--text-color);
            font-weight: 500;
            width: 100%;
            max-width: 300px;
            transition: border-color 0.3s ease, box-shadow 0.3s ease;
            font-family: 'Inter', sans-serif;
        }
        select:focus, input[type="number"]:focus, input[type="text"]:focus, textarea:focus {
            outline: none;
            border-color: var(--primary-color);
            box-shadow: 0 0 0 4px hsla(220, 60%, 75%, 0.3);
        }
        /* Invalid input styling */
        input.is-invalid {
            border-color: var(--danger-color);
            box-shadow: 0 0 0 4px hsla(0, 60%, 75%, 0.3);
        }
        .error-message {
            color: var(--danger-color);
            font-size: 0.85rem;
            margin-top: var(--spacing-xxs);
            text-align: center;
            width: 100%;
        }

        textarea {
            resize: vertical;
            min-height: 110px;
            max-width: 100%;
        }
        .exercise-list-container {
            border-radius: var(--border-radius-large);
            background: var(--input-bg);
            margin-bottom: var(--spacing-xxl);
            box-shadow: 0 6px 15px var(--shadow-medium);
            overflow: hidden;
        }

        /* Desktop Table Styles */
        .exercise-list-container .desktop-table {
            width: 100%;
            border-collapse: separate; 
            border-spacing: 0; 
            table-layout: auto; 
        }
        .exercise-list-container .desktop-table th, 
        .exercise-list-container .desktop-table td {
            padding: var(--spacing-md) var(--spacing-sm);
            text-align: center;
            border-bottom: 1px solid var(--border-color); 
            transition: background-color 0.3s ease;
            font-weight: 500;
        }
        .exercise-list-container .desktop-table th {
            background: linear-gradient(135deg, var(--primary-grad-start), var(--primary-grad-end));
            color: var(--text-on-color);
            text-transform: uppercase;
            font-size: 0.85rem; 
            letter-spacing: 1px; 
            position: sticky;
            top: 0;
            z-index: 10;
            font-weight: 700;
        }
        .exercise-list-container .desktop-table th:first-child { border-top-left-radius: var(--border-radius-large); }
        .exercise-list-container .desktop-table th:last-child { border-top-right-radius: var(--border-radius-large); }

        .exercise-list-container .desktop-table .exercise-row {
            transition: all 0.3s ease; 
        }
        .exercise-list-container .desktop-table .exercise-row:nth-child(even) {
            background-color: var(--row-bg-even);
        }
        .exercise-list-container .desktop-table .exercise-row:hover {
            background-color: hsla(200, 70%, 95%, 0.3); 
        }
        body.dark-mode .exercise-list-container .desktop-table .exercise-row:hover {
            background-color: hsla(220, 20%, 28%, 0.5); 
        }

        .exercise-list-container .desktop-table .exercise-row.superset-group {
            border-left: 4px solid var(--info-color); 
        }

        .exercise-list-container .desktop-table .actions-col { 
            width: max-content; 
            padding-left: var(--spacing-sm); 
            padding-right: var(--spacing-sm); 
        }
        .exercise-list-container .desktop-table .exercise-col {
            width: 0%; 
            max-width: 280px; 
            text-align: left; 
            padding-left: var(--spacing-md); 
            white-space: normal;
            font-weight: 600; 
            font-size: 1.05rem; 
        }

        /* Input field centering */
        .exercise-list-container .desktop-table .serie-input input {
            text-align: center;
        }
        /* Centering inputs within calculator/quick edit modals */
        .modal-content .controls input[type="number"],
        .modal-content .controls input[type="text"] {
            text-align: center;
        }
        .modal-content .controls {
            justify-content: center;
        }

        /* Mobile Card Styles */
        .exercise-list-container .mobile-cards {
            display: none;
            flex-direction: column;
            gap: var(--spacing-lg);
            padding: var(--spacing-lg);
        }
        .exercise-card {
            background-color: var(--input-bg);
            border-radius: var(--border-radius-medium);
            padding: var(--spacing-md);
            box-shadow: 0 4px 10px var(--shadow-light);
            display: flex;
            flex-direction: column;
            gap: var(--spacing-sm);
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }
        .exercise-card.superset-group {
            border-left: 4px solid var(--info-color); 
        }
        .exercise-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 14px var(--shadow-medium);
        }
        .exercise-card h4 {
            font-size: 1.25rem;
            font-weight: 700;
            color: var(--header-color);
            margin: 0;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }
        .exercise-card .series-group {
            display: flex;
            flex-direction: column;
            gap: var(--spacing-xs);
            padding: var(--spacing-sm) 0;
            border-top: 1px solid var(--border-color);
            border-bottom: 1px solid var(--border-color);
        }
        .exercise-card .series-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.95rem;
            color: var(--text-color);
        }
        .exercise-card .series-row strong {
            font-weight: 600;
            color: var(--primary-color);
        }
        .exercise-card .series-input-group {
            display: flex;
            gap: var(--spacing-xs);
            align-items: center;
        }
        .exercise-card .series-input-group input {
            width: 65px;
            padding: var(--spacing-xs);
            font-size: 0.9rem;
            text-align: center;
        }
        .serie-input-delete { /* Style for the new delete 'x' button for series */
            background: none;
            border: none;
            color: var(--danger-color);
            font-size: 1.1rem;
            cursor: pointer;
            margin-left: var(--spacing-xxs);
            opacity: 0.7;
            transition: opacity 0.2s ease;
            padding: 0; /* Remove default padding */
            line-height: 1; /* Align 'x' vertically */
        }
        .serie-input-delete:hover {
            opacity: 1;
        }
        .exercise-card .series-input-group input.completed {
            background: linear-gradient(135deg, var(--success-grad-start), var(--success-grad-end));
            color: var(--text-on-color);
            border-color: var(--success-color);
        }
        .exercise-card .card-stats {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: var(--spacing-sm);
            font-size: 0.9rem;
        }
        .exercise-card .card-stat-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: var(--spacing-xxs);
        }
        .exercise-card .card-stat-label {
            color: var(--sub-header-color);
            font-size: 0.85rem;
        }
        .exercise-card .card-stat-value {
            font-weight: 700;
            color: var(--primary-color);
            font-size: 1.1rem;
        }
        .exercise-card .card-actions {
            display: flex;
            justify-content: space-around;
            gap: var(--spacing-sm);
            margin-top: var(--spacing-md);
            align-items: center;
        }
        .exercise-card .card-actions .btn {
            flex-grow: 1;
            padding: var(--spacing-xs) var(--spacing-sm);
            font-size: 0.9rem;
            border-radius: var(--border-radius-base);
        }
        /* Style for quick-edit button on mobile as per user's request */
        @media (max-width: 768px) {
            .exercise-card .card-actions .btn[data-action="quick-edit"] {
                background: none; /* No background */
                color: var(--info-color); /* Info color for text/icon */
                border: none; /* No border */
                box-shadow: none; /* No shadow */
                opacity: 0.8; /* Slight transparency */
            }
            .exercise-card .card-actions .btn[data-action="quick-edit"]:hover {
                background-color: hsla(200, 70%, 95%, 0.3); /* Subtle hover effect */
                color: var(--info-color);
            }
        }
        
        .serie-input {
            display: flex;
            flex-direction: column;
            gap: var(--spacing-xs);
            align-items: center;
        }
        .serie-input input {
            width: 60px;
            padding: var(--spacing-xs);
            font-size: 0.95rem;
            text-align: center;
            font-weight: 500;
            border-radius: var(--border-radius-xs);
        }
        .serie-input input.completed {
            background: linear-gradient(135deg, var(--success-grad-start), var(--success-grad-end));
            color: var(--text-on-color);
            border-color: var(--success-color);
        }
        .tonnage-high, .onerm-high {
            background: linear-gradient(135deg, var(--success-grad-start), var(--success-grad-end));
            color: var(--text-on-color);
            border-radius: var(--border-radius-xs);
            padding: var(--spacing-xs) var(--spacing-sm);
            font-weight: 600;
            font-size: 0.9rem;
            opacity: 0.9;
            box-shadow: 0 2px 5px var(--shadow-light);
        }
        .timer-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: var(--spacing-xs);
        }
        .timer-btn {
            padding: 0.6rem 1rem;
            border: none;
            border-radius: var(--border-radius-button);
            cursor: pointer;
            font-size: 0.9rem;
            font-weight: 600;
            color: var(--text-on-color);
            transition: all 0.3s ease, box-shadow 0.3s ease; 
            box-shadow: 0 3px 8px var(--shadow-light);
        }
        .timer-btn:hover { 
            transform: translateY(-2px);
            box-shadow: 0 4px 10px var(--shadow-medium);
        }
        .timer-btn[data-timer-action="start"] { background: linear-gradient(135deg, var(--success-grad-start), var(--success-grad-end)); }
        .timer-btn[data-timer-action="stop"] { background: linear-gradient(135deg, var(--danger-grad-start), var(--danger-grad-end)); }
        .timer-btn[data-timer-action="reset"] { background: linear-gradient(135deg, var(--warning-grad-start), var(--warning-grad-end)); }
        .timer-display { 
            font-size: 1.1rem;
            font-weight: 600;
            color: var(--text-color);
            transition: color 0.3s ease;
        }
        .timer-display.timer-active { 
            color: var(--success-color);
            animation: pulse 1.2s infinite; 
            font-weight: 700;
        }
        @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.7; } }

        /* Summary section */
        .summary-section {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: var(--spacing-lg);
            margin-bottom: var(--spacing-xxl);
        }
        .summary-card { 
            padding: var(--spacing-xl);
            border-radius: var(--border-radius-large);
            text-align: center; 
            background: var(--input-bg);
            box-shadow: 0 5px 12px var(--shadow-medium);
            border-left: 5px solid var(--primary-color);
            transition: transform 0.2s ease, box-shadow 0.2s ease;
            position: relative;
            overflow: hidden;
        }
        .summary-card:hover {
            transform: translateY(-4px);
            box-shadow: 0 8px 18px var(--shadow-strong);
        }
        .summary-card h3 {
            font-size: 1.1rem;
            color: var(--sub-header-color);
            margin-bottom: var(--spacing-sm);
            display: flex;
            align-items: center;
            justify-content: center;
            gap: var(--spacing-xs);
        }
        .summary-card .value { 
            font-size: 2.8rem;
            font-weight: 800;
            color: var(--primary-color);
            letter-spacing: -0.04em;
        }
        body.dark-mode .summary-card .value { 
            color: hsl(220, 60%, 85%);
            text-shadow: 0 0 8px hsla(220, 60%, 85%, 0.3);
        }
        .summary-card .card-icon {
            font-size: 1.5rem;
            color: var(--primary-color);
            opacity: 0.2;
            position: absolute;
            top: var(--spacing-sm);
            right: var(--spacing-sm);
        }

        .action-buttons { 
            display: flex;
            flex-wrap: wrap; 
            gap: var(--spacing-lg);
            justify-content: center; 
            margin-top: var(--spacing-xxl); 
        }
        .btn { 
            padding: var(--spacing-md) var(--spacing-xl);
            border: none; 
            border-radius: var(--border-radius-button);
            cursor: pointer; 
            font-size: 1rem;
            font-weight: 600; 
            font-family: 'Inter', sans-serif;
            color: var(--text-on-color);
            transition: all 0.3s ease, box-shadow 0.3s ease;
            box-shadow: 0 4px 10px var(--shadow-light);
        }
        .btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 7px 14px var(--shadow-medium);
        }
        .btn-primary { background: linear-gradient(135deg, var(--primary-grad-start), var(--primary-grad-end)); }
        .btn-secondary { background: linear-gradient(135deg, var(--warning-grad-start), var(--warning-grad-end)); }
        .btn-danger { background: linear-gradient(135deg, var(--danger-grad-start), var(--danger-grad-end)); }
        .btn-success { background: linear-gradient(135deg, var(--success-grad-start), var(--success-grad-end)); }
        .btn-info { background: linear-gradient(135deg, var(--info-grad-start), var(--info-grad-end)); }

        .btn-outline {
            background: none;
            color: var(--primary-color);
            border: 2px solid var(--primary-color);
            box-shadow: none;
        }
        .btn-outline:hover {
            background-color: hsla(220, 60%, 75%, 0.1);
            box-shadow: 0 4px 10px var(--shadow-light);
        }
        .btn-ghost {
            background: none;
            color: var(--info-color);
            border: 1px solid transparent;
            box-shadow: none;
        }
        .btn-ghost:hover {
            background: hsla(200, 70%, 90%, 0.2);
            border-color: var(--info-color);
            color: var(--info-color);
        }
        body.dark-mode .btn-ghost:hover {
            background: hsla(200, 45%, 50%, 0.2);
        }


        /* Notifications */
        .notification { 
            position: fixed;
            top: var(--spacing-xl); 
            right: var(--spacing-xl); 
            padding: var(--spacing-md) var(--spacing-lg);
            border-radius: var(--border-radius-base);
            color: var(--text-on-color); 
            z-index: 1001; 
            transform: translateX(120%); 
            opacity: 0;
            transition: transform 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94), opacity 0.5s ease; 
            box-shadow: 0 8px 20px var(--shadow-medium);
        }
        .notification.show { 
            transform: translateX(0);
            opacity: 1;
        }
        .notification.success { background: linear-gradient(135deg, var(--success-grad-start), var(--success-grad-end)); }
        .notification.error { background: linear-gradient(135deg, var(--danger-grad-start), var(--danger-grad-end)); }
        .notification.info { background: linear-gradient(135deg, var(--info-grad-start), var(--info-grad-end)); }

        /* Modals */
        .modal-overlay { 
            position: fixed;
            top: 0; 
            left: 0; 
            width: 100%; 
            height: 100%; 
            background: hsla(220, 10%, 10%, 0.6);
            display: flex; 
            align-items: center; 
            justify-content: center;
            z-index: 1000; 
            backdrop-filter: blur(8px);
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease, visibility 0.3s ease;
        }
        .modal-overlay.show {
            opacity: 1;
            visibility: visible;
        }
        .modal-content { 
            background: var(--container-bg);
            padding: var(--spacing-xxl);
            border-radius: var(--border-radius-large);
            max-width: 900px;
            max-height: 90vh; 
            overflow-y: auto; 
            position: relative; 
            box-shadow: 0 20px 40px var(--shadow-strong);
            transform: translateY(-20px);
            transition: transform 0.3s ease, opacity 0.3s ease;
            opacity: 0;
        }
        .modal-overlay.show .modal-content {
            transform: translateY(0);
            opacity: 1;
        }
        .modal-close-btn { 
            position: absolute;
            top: var(--spacing-md); 
            right: var(--spacing-md); 
            background: transparent; 
            color: var(--text-color); 
            border: none; 
            border-radius: 50%; 
            width: 40px;
            height: 40px; 
            font-size: 1.8rem;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .modal-close-btn:hover {
            background-color: var(--border-color);
            transform: rotate(90deg); 
        }

        /* History */
        #historyList { display: flex; flex-direction: column; gap: var(--spacing-md); }
        .history-item { 
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius-base);
            padding: var(--spacing-md);
            display: flex; 
            justify-content: space-between; 
            align-items: center; 
            flex-wrap: wrap; 
            gap: var(--spacing-sm); 
            background: var(--input-bg);
            box-shadow: 0 3px 10px var(--shadow-light);
            transition: box-shadow 0.3s ease, transform 0.2s ease;
        }
        .history-item:hover { 
            box-shadow: 0 5px 15px var(--shadow-medium);
            transform: translateY(-2px);
        }
        .history-item div:first-child {
            flex-grow: 1;
            font-size: 0.95rem;
        }
        .history-details { 
            display: none;
            width: 100%; 
            margin-top: var(--spacing-md);
            padding-top: var(--spacing-md); 
            border-top: 1px solid var(--border-color);
        }
        .history-details.visible { display: block; }
        .history-details ul {
            list-style: none;
            padding: 0;
            margin: var(--spacing-sm) 0 0 0;
        }
        .history-details li {
            padding: var(--spacing-xs) 0;
            border-bottom: 1px dashed var(--border-color);
        }
        .history-details li:last-child {
            border-bottom: none;
        }
        .progress-bar { 
            width: 100%;
            height: 10px;
            background: var(--border-color); 
            border-radius: 5px;
            overflow: hidden; 
            margin: var(--spacing-xl) 0;
        }
        .progress-fill { 
            height: 100%;
            background: linear-gradient(135deg, var(--success-grad-start), var(--success-grad-end)); 
            border-radius: 5px; 
            transition: width 0.6s cubic-bezier(0.25, 0.46, 0.45, 0.94);
        }
        .hidden { display: none !important; }
        .show-notes-section {
            display: block !important; /* Force display when toggled */
        }
        .hide-notes-section {
            display: none !important; /* Force hide when toggled */
        }

        .theme-switcher { 
            position: absolute;
            top: var(--spacing-md); 
            right: var(--spacing-md); 
            z-index: 11; 
        }
        .theme-switcher .btn {
            padding: var(--spacing-sm) var(--spacing-md);
            font-size: 1.2rem;
            border-radius: var(--border-radius-base);
            box-shadow: 0 2px 5px var(--shadow-light);
            background: var(--input-bg);
            color: var(--text-color);
            transition: background 0.3s ease, color 0.3s ease, transform 0.2s ease, box-shadow 0.2s ease;
        }
        .theme-switcher .btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 8px var(--shadow-medium);
        }
        
        .add-exercise-section {
            display: flex;
            justify-content: center; 
            gap: var(--spacing-md);
            margin-top: var(--spacing-xl); 
            padding: var(--spacing-lg); 
            background: hsla(0, 0%, 100%, 0.1); 
            border-radius: var(--border-radius-large); 
            position: relative; 
            align-items: center;
            box-shadow: 0 3px 8px var(--shadow-light);
        }
        .add-exercise-section .input-group {
            display: flex;
            width: 100%;
            max-width: 500px;
            gap: var(--spacing-sm);
        }
        /* Mobile specific adjustments for autocomplete suggestions */
        @media (max-width: 768px) {
            #autocompleteSuggestions {
                top: auto;
                bottom: 100%; /* Position above the input field on mobile */
                left: 0;
                transform: translateX(0);
                width: 100%;
                max-width: 100%;
                margin-bottom: var(--spacing-xs);
                max-height: 150px;
                overflow-y: auto;
                border-radius: var(--border-radius-base); /* Apply full border-radius for standalone look */
                box-shadow: 0 -4px 10px var(--shadow-medium);
            }
            .add-exercise-section {
                /* On mobile, to ensure autocomplete suggestions appear above the input, 
                   we make the input-group the positioned parent and give it relative positioning */
                position: relative;
            }
            .add-exercise-section .input-group {
                position: relative; /* Establish positioning context for suggestions */
                flex-direction: column-reverse; /* Put suggestions above input */
            }
        }
        #autocompleteSuggestions.show {
            opacity: 1;
            visibility: visible;
        }
        #autocompleteSuggestions div {
            padding: var(--spacing-sm) var(--spacing-md);
            cursor: pointer;
            transition: background-color 0.2s ease;
        }
        #autocompleteSuggestions div:hover { 
            background-color: var(--border-color);
            color: var(--primary-color);
            font-weight: 600;
        }
        
        .btn-danger[data-action="remove"] {
            background: none;
            color: var(--danger-color);
            padding: var(--spacing-xs) var(--spacing-sm);
            border: none;
            font-size: 1.2rem; 
            opacity: 0.7;
            box-shadow: none;
        }
        .btn-danger[data-action="remove"]:hover {
            background: hsla(0, 60%, 80%, 0.15);
            color: var(--danger-color); 
            opacity: 1;
            transform: none;
            box-shadow: none;
        }
        .quick-edit-btn, .link-btn {
            background: none; border: none; font-size: 1rem; color: var(--info-color);
            cursor: pointer; padding: var(--spacing-xs); border-radius: var(--border-radius-xs); transition: all 0.2s ease;
            opacity: 0.8;
        }
        .quick-edit-btn:hover, .link-btn:hover { 
            background-color: hsla(200, 70%, 75%, 0.15);
            opacity: 1; 
            transform: none;
        }
        
        /* NEW/MODIFIED: Superset button styles */
        .link-btn.linking, 
        .link-btn.active-superset {
            background: linear-gradient(135deg, var(--info-grad-start), var(--info-grad-end));
            color: var(--text-on-color);
            opacity: 1;
        }
        .link-btn.active-superset:hover {
            background: linear-gradient(135deg, var(--info-grad-end), var(--info-grad-start));
        }

        .next-superset-exercise {
            animation: pulse-border 1.5s infinite; /* Changed from pulse-row */
            box-shadow: 0 0 10px 3px var(--info-color); /* Added a subtle glow */
        }
        @keyframes pulse-border { /* New animation for superset indication */
            0% { border-color: var(--info-color); }
            50% { border-color: transparent; }
            100% { border-color: var(--info-color); }
        }
        /* Keep pulse-row for consistency with comments if not used elsewhere, but new name is better */
        @keyframes pulse-row { /* Original pulse-row, if still referenced */
            0% {
                box-shadow: inset 0 2px 0 0 var(--success-color), inset 0 -2px 0 0 var(--success-color);
            }
            50% {
                box-shadow: inset 0 2px 0 0 transparent, inset 0 -2px 0 0 transparent;
            }
            100% {
                box-shadow: inset 0 2px 0 0 var(--success-color), inset 0 -2px 0 0 var(--success-color);
            }
        }
        
        /* New Styles for Calculator Modal Tabs and Goal Cards */
        .modal-tabs {
            display: flex;
            border-bottom: 1px solid var(--border-color);
            margin-bottom: var(--spacing-lg);
        }
        .modal-tab-btn {
            padding: var(--spacing-sm) var(--spacing-lg);
            cursor: pointer;
            border: none;
            background-color: transparent;
            color: var(--text-color);
            font-weight: 600;
            border-bottom: 3px solid transparent;
            transition: all 0.3s ease;
            flex-grow: 1;
        }
        .modal-tab-btn.active {
            color: var(--primary-color);
            border-bottom-color: var(--primary-color);
        }
        #goalResultsContainer {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: var(--spacing-lg);
            margin-top: var(--spacing-xl);
        }
        .goal-card {
            background-color: var(--input-bg);
            border-radius: var(--border-radius-base);
            padding: var(--spacing-lg);
            text-align: center;
            border: 1px solid var(--border-color);
            box-shadow: 0 4px 10px var(--shadow-light);
            transition: transform 0.2s ease, box-shadow 0.2s ease;
            position: relative;
        }
        .goal-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 8px 15px var(--shadow-medium);
        }
        .goal-card h4 {
            margin: 0 0 var(--spacing-xs) 0;
            font-size: 1.15rem;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: var(--spacing-xs);
            color: var(--header-color);
        }
        .goal-card .icon {
            font-size: 1.6rem;
            color: var(--primary-color);
        }
        .goal-card .weight-range {
            font-size: 1.5rem;
            font-weight: 700;
            color: var(--success-color);
        }
        .goal-card .rep-range {
            font-size: 0.95rem;
            color: var(--sub-header-color);
            opacity: 0.9;
            margin-top: var(--spacing-sm);
        }
        /* Distinct background colors for goal cards */
        .goal-card.hypertrophy {
            background-color: hsl(200, 80%, 95%); /* Swapped with power's previous color */
            border: 1px solid hsl(200, 80%, 85%);
        }
        .goal-card.strength {
            background-color: hsl(0, 70%, 95%);
            border: 1px solid hsl(0, 70%, 85%);
        }
        .goal-card.endurance {
            background-color: hsl(40, 90%, 95%);
            border: 1px solid hsl(40, 90%, 85%);
        }
        .goal-card.power {
            background-color: hsl(260, 70%, 95%); /* Swapped with hypertrophy's previous color */
            border: 1px solid hsl(260, 70%, 85%);
        }

        .plate-result-message {
            font-weight: bold;
            padding: var(--spacing-xs) var(--spacing-sm);
            border-radius: var(--border-radius-xs);
            display: inline-block;
            margin-top: var(--spacing-sm);
        }
        .plate-result-message.success {
            color: var(--text-on-color);
            background: linear-gradient(135deg, var(--success-grad-start), var(--success-grad-end));
        }
        .plate-result-message.danger {
            color: var(--text-on-color);
            background: linear-gradient(135deg, var(--danger-grad-start), var(--danger-grad-end));
        }
        #platesResult h3 {
            font-size: 1.25rem;
            margin-bottom: var(--spacing-sm);
            color: var(--header-color);
        }
        #platesResult p span {
            font-weight: 700;
            color: var(--primary-color);
        }
        #platesResult p span {
            background-color: var(--border-color);
            padding: 3px 6px;
            border-radius: 6px;
            font-weight: 600;
            font-size: 0.9em;
            color: var(--text-color);
            white-space: nowrap;
        }

        /* Tooltips */
        .tooltip {
            position: relative;
            display: inline-block;
        }
        .tooltip .tooltiptext {
            visibility: hidden;
            background-color: var(--header-color);
            color: var(--text-on-color);
            text-align: center;
            border-radius: 6px;
            padding: 5px 10px;
            position: absolute;
            z-index: 1;
            bottom: 125%;
            left: 50%;
            margin-left: -60px;
            opacity: 0;
            transition: opacity 0.3s;
            font-size: 0.8rem;
            width: 120px;
        }
        .tooltip .tooltiptext::after {
            content: "";
            position: absolute;
            top: 100%;
            left: 50%;
            margin-left: -5px;
            border-width: 5px;
            border-style: solid;
            border-color: var(--header-color) transparent transparent transparent;
        }
        .tooltip:hover .tooltiptext {
            visibility: visible;
            opacity: 1;
        }
        
        /* PWA Install Prompt */
        #pwaInstallPrompt {
            position: fixed;
            bottom: var(--spacing-xxl);
            left: 50%;
            transform: translateX(-50%);
            background: linear-gradient(135deg, var(--primary-grad-start), var(--primary-grad-end));
            color: var(--text-on-color);
            padding: var(--spacing-md) var(--spacing-lg);
            border-radius: var(--border-radius-button);
            box-shadow: 0 5px 15px var(--shadow-medium);
            display: flex;
            align-items: center;
            gap: var(--spacing-md);
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease, visibility 0.3s ease;
        }
        #pwaInstallPrompt.show {
            opacity: 1;
            visibility: visible;
        }
        #pwaInstallPrompt button {
            background: var(--text-on-color);
            color: var(--primary-color);
            border: none;
            padding: var(--spacing-xs) var(--spacing-sm);
            border-radius: var(--border-radius-base);
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        #pwaInstallPrompt button:hover {
            opacity: 0.9;
        }
        #pwaInstallPrompt .close-btn {
            background: none;
            color: var(--text-on-color);
            font-size: 1.2rem;
            opacity: 0.7;
        }
        #pwaInstallPrompt .close-btn:hover {
            opacity: 1;
        }


        /* Bottom Navigation Bar */
        .bottom-navigation {
            position: fixed; /* Always present on screen */
            bottom: 0; /* Align to the bottom */
            left: 0;
            width: 100%;
            background: var(--container-bg);
            box-shadow: 0 -5px 15px var(--shadow-medium);
            display: flex;
            justify-content: space-around;
            align-items: center;
            padding: var(--spacing-sm) var(--spacing-xs);
            z-index: 999;
            border-top-left-radius: var(--border-radius-large);
            border-top-right-radius: var(--border-radius-large);
            padding-bottom: env(safe-area-inset-bottom, var(--spacing-sm)); /* For iPhones with notch */
            height: 70px; /* Fixed height for consistency */
        }
        .bottom-navigation .btn {
            flex: 1;
            margin: 0 var(--spacing-xxs); /* Smaller margin for more buttons */
            padding: var(--spacing-xs) var(--spacing-sm);
            font-size: 0.9rem;
            border-radius: var(--border-radius-medium);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: var(--spacing-xxs);
            color: var(--text-color);
            background: none;
            box-shadow: none;
            transition: all 0.2s ease;
        }
        .bottom-navigation .btn i {
            font-size: 1.2rem;
            color: var(--sub-header-color);
        }
        .bottom-navigation .btn span {
            font-size: 0.75rem;
            font-weight: 500;
        }
        .bottom-navigation .btn:hover {
            background-color: var(--border-color);
            transform: translateY(-2px);
        }
        .bottom-navigation .btn-active {
            color: var(--primary-color);
            background: hsla(220, 60%, 75%, 0.1);
        }
        .bottom-navigation .btn-active i {
            color: var(--primary-color);
        }

        /* Responsive adjustments */
        @media (min-width: 769px) {
            .exercise-list-container .mobile-cards {
                display: none !important;
            }
            .bottom-navigation {
                display: none !important; /* Hide on desktop */
            }
            body { /* Adjust padding for desktop view to avoid issues with fixed bottom nav */
                padding-bottom: var(--spacing-xxl);
            }
            .session-notes-section {
                display: block !important; /* Always visible on desktop */
            }
        }

        @media (max-width: 768px) {
            body { 
                padding: var(--spacing-md); 
                padding-bottom: calc(var(--spacing-md) + 70px); /* Add space for fixed bottom nav */
            }
            .main-container { padding: var(--spacing-lg); border-radius: var(--border-radius-base); }
            h2 { font-size: 2rem; margin-bottom: var(--spacing-xl); }
            .lyftiv-logo { width: 40px; height: 40px; }
            .controls, .add-exercise-section { flex-direction: column; align-items: stretch; }
            .controls label, .controls input, .controls select, .add-exercise-section .input-group, .add-exercise-section button {
                max-width: 100%;
                width: 100%;
            }
            .add-exercise-section .input-group { flex-direction: column; }
            .add-exercise-section .input-group input, .add-exercise-section .input-group button { width: 100%; }

            /* Mobile specific adjustments for autocomplete suggestions */
            #autocompleteSuggestions {
                top: auto;
                bottom: 100%; /* Position above the input field on mobile */
                left: 0;
                transform: translateX(0);
                width: 100%;
                max-width: 100%;
                margin-bottom: var(--spacing-xs);
                max-height: 150px;
                overflow-y: auto;
                border-radius: var(--border-radius-base); /* Apply full border-radius for standalone look */
                box-shadow: 0 -4px 10px var(--shadow-medium);
            }
            .add-exercise-section {
                position: relative;
            }
            .add-exercise-section .input-group {
                position: relative; /* Establish positioning context for suggestions */
                flex-direction: column-reverse; /* Put suggestions above input */
            }


            /* Hide table on mobile */
            .exercise-list-container .desktop-table {
                display: none; 
            }
            /* Show cards on mobile */
            .exercise-list-container .mobile-cards {
                display: flex;
            }

            .action-buttons { 
                display: flex;
                margin-top: var(--spacing-xl);
                justify-content: center;
                flex-wrap: wrap;
                gap: var(--spacing-md);
            }
            .action-buttons .btn {
                width: calc(50% - var(--spacing-sm));
                padding: var(--spacing-sm) var(--spacing-md);
                font-size: 0.9rem;
            }
            .action-buttons .btn i {
                font-size: 1.1rem;
            }

            .notification { 
                width: calc(100% - var(--spacing-xl) * 2);
                left: var(--spacing-xl); 
                right: var(--spacing-xl); 
                top: var(--spacing-md); 
            }
            .modal-content { 
                width: calc(100% - var(--spacing-lg) * 2);
                margin: var(--spacing-md); 
                padding: var(--spacing-lg); 
                border-radius: var(--border-radius-base); 
            }
            .summary-card .value { font-size: 2.2rem; }
            .summary-card h3 { font-size: 1.1rem; }
            .summary-section {
                grid-template-columns: 1fr;
                gap: var(--spacing-md);
            }
            .summary-card {
                border-left: none;
                border-bottom: 5px solid var(--primary-color);
                padding: var(--spacing-md);
            }
        }
        @media (max-width: 480px) {
            .summary-card .value { font-size: 2rem; }
            .summary-card h3 { font-size: 1rem; }
        }

    </style>
</head>
<body>
    <div class="main-container">
        <div class="theme-switcher">
            <button id="themeToggleBtn" aria-label="Changer de thÃ¨me">ð</button>
        </div>
        <h2>
            <svg class="lyftiv-logo" viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg">
                <defs>
                    <linearGradient id="lyftivLogoGradient" x1="0%" y1="0%" x2="100%" y2="100%">
                        <stop offset="0%" stop-color="hsl(200, 80%, 85%)" />
                        <stop offset="100%" stop-color="hsl(260, 60%, 85%)" />
                    </linearGradient>
                </defs>
                <rect x="0" y="0" width="100" height="100" rx="20" ry="20" fill="url(#lyftivLogoGradient)"/>
                <path d="M 15 50 C 15 35 30 30 50 30 C 70 30 85 35 85 50 C 85 65 70 70 50 70 C 30 70 15 65 15 50 Z M 25 50 L 75 50 M 25 35 L 25 65 M 75 35 L 75 65" stroke="hsl(220, 60%, 55%)" stroke-width="3.5" fill="none" stroke-linecap="round"/>
                <circle cx="25" cy="50" r="14" stroke="hsl(220, 60%, 55%)" stroke-width="2" fill="none"/>
                <circle cx="25" cy="50" r="10" stroke="hsl(220, 60%, 55%)" stroke-width="2" fill="none"/>
                <circle cx="25" cy="50" r="6" stroke="hsl(220, 60%, 55%)" stroke-width="2" fill="none"/>
                <circle cx="75" cy="50" r="14" stroke="hsl(220, 60%, 55%)" stroke-width="2" fill="none"/>
                <circle cx="75" cy="50" r="10" stroke="hsl(220, 60%, 55%)" stroke-width="2" fill="none"/>
                <circle cx="75" cy="50" r="6" stroke="hsl(220, 60%, 55%)" stroke-width="2" fill="none"/>
                <rect x="35" y="48.5" width="30" height="3" rx="1.5" ry="1.5" fill="white"/>
            </svg>
            Lyftiv
        </h2>
        
        <div class="controls">
          <label for="sessionSelect"><strong>SÃ©ance:</strong></label>
          <select id="sessionSelect" aria-label="SÃ©lectionner une sÃ©ance d'entraÃ®nement">
            <!-- Options will be populated by JS -->
          </select>
          <button class="btn btn-outline" id="createNewSessionTypeBtn" aria-label="CrÃ©er une nouvelle sÃ©ance">Nouvelle SÃ©ance</button>
          <!-- New Delete Current Session Button -->
          <button class="btn btn-danger" id="deleteCurrentSessionBtn" aria-label="Supprimer la sÃ©ance actuelle" title="Supprimer la sÃ©ance actuelle (personnalisÃ©e)"><i class="fas fa-trash-alt"></i> Supprimer SÃ©ance</button>
        </div>
        
        <div class="progress-bar" role="progressbar" aria-valuenow="0" aria-valuemin="0" aria-valuemax="100" id="progressBar">
          <div class="progress-fill" id="progressFill"></div>
        </div>
        
        <div id="exerciseListContainer" class="exercise-list-container">
            <!-- Content will be populated by JS -->
        </div>
        
        <section class="controls add-exercise-section" id="addExerciseSection">
            <div class="input-group">
                <input type="text" id="customExercise" placeholder="Ajouter un exercice" aria-label="Nom de l'exercice personnalisÃ©">
                <button class="btn btn-success" id="addExerciseBtn" aria-label="Ajouter l'exercice"><i class="fas fa-plus"></i> Ajouter</button>
            </div>
            <div id="autocompleteSuggestions" class="hidden" role="listbox" aria-label="Suggestions d'exercices"></div>
        </section>

        <section class="summary-section">
            <div class="summary-card">
                <span class="card-icon" aria-hidden="true"><i class="fas fa-weight-hanging"></i></span>
                <h3>Tonnage Total</h3>
                <div class="value" id="totalTonnage" aria-live="polite">0 kg</div>
            </div>
            <div class="summary-card">
                <span class="card-icon" aria-hidden="true"><i class="fas fa-chart-line"></i></span>
                <h3>Semaine PrÃ©cÃ©dente</h3>
                <input type="text" id="previousWeek" placeholder="Tonnage PrÃ©c. (kg)" aria-label="Tonnage de la semaine prÃ©cÃ©dente">
            </div>
            <div class="summary-card">
                <span class="card-icon" aria-hidden="true"><i class="fas fa-arrow-up"></i></span>
                <h3>Progression</h3>
                <div class="value" id="delta" aria-live="polite">0 kg</div>
            </div>
            <div class="summary-card">
                <span class="card-icon" aria-hidden="true"><i class="fas fa-clock"></i></span>
                <h3>Temps Total</h3>
                <div class="value" id="totalTime" aria-live="polite">00:00:00</div>
                <button id="toggleWorkoutTimerBtn" class="btn btn-secondary" aria-label="Mettre en pause ou reprendre le minuteur" style="margin-top: var(--spacing-sm);">
                    <span id="timerPlayPauseIcon" aria-hidden="true">â¯ï¸</span>
                    <span id="timerPlayPauseText">Pause</span>
                </button>
            </div>
        </section>

        <section class="controls session-notes-section" id="sessionNotesSection">
            <label for="sessionNotes"><strong>Notes de SÃ©ance:</strong></label>
            <textarea id="sessionNotes" placeholder="Ajouter des notes sur la sÃ©ance..." aria-label="Notes de sÃ©ance"></textarea>
        </section>
        
        <section class="action-buttons">
          <button class="btn btn-success" id="finishSessionBtn" aria-label="Terminer et Sauvegarder la sÃ©ance"><i class="fas fa-save" aria-hidden="true"></i> Terminer & Sauvegarder</button>
          <button class="btn btn-primary" id="viewHistoryBtn" aria-label="Voir l'historique"><i class="fas fa-book" aria-hidden="true"></i> Historique</button>
          <button class="btn btn-primary" id="plateCalculatorBtn" aria-label="Ouvrir les calculateurs"><i class="fas fa-calculator" aria-hidden="true"></i> Calculateurs</button>
        </section>

        <section class="action-buttons" style="margin-top: var(--spacing-md);">
            <button class="btn btn-info" id="exportBtn" aria-label="Exporter les donnÃ©es"><i class="fas fa-file-export" aria-hidden="true"></i> Exporter</button>
            <button class="btn btn-info" id="importBtn" aria-label="Importer les donnÃ©es"><i class="fas fa-file-import" aria-hidden="true"></i> Importer</button>
        </section>
        <input type="file" id="importFile" class="hidden" accept=".json,.csv" aria-label="Fichier d'importation">
    </div>
    
    <div id="notification-container" aria-live="polite" aria-atomic="true"></div>
    
    <!-- PWA Install Prompt (new) -->
    <div id="pwaInstallPrompt" class="hidden" role="dialog" aria-modal="true" aria-labelledby="pwaInstallTitle">
        <span id="pwaInstallTitle" style="font-weight: 600;">Ajoutez Lyftiv Ã  votre Ã©cran d'accueil !</span>
        <button id="installPwaBtn" aria-label="Installer l'application">Installer</button>
        <button id="closePwaPrompt" class="close-btn" aria-label="Fermer le message d'installation">&times;</button>
    </div>

    <div id="historyModal" class="modal-overlay hidden" role="dialog" aria-modal="true" aria-labelledby="historyModalTitle">
      <div class="modal-content">
          <button id="closeHistoryModal" class="modal-close-btn" aria-label="Fermer le modal historique">&times;</button>
          <h2 id="historyModalTitle">Historique des SÃ©ances</h2>
          <div id="historyList"></div>
      </div>
    </div>

    <div id="newSessionModal" class="modal-overlay hidden" role="dialog" aria-modal="true" aria-labelledby="newSessionModalTitle">
        <div class="modal-content">
            <button id="closeNewSessionModal" class="modal-close-btn" aria-label="Fermer le modal de nouvelle sÃ©ance">&times;</button>
            <h2 id="newSessionModalTitle">CrÃ©er une Nouvelle SÃ©ance</h2>
            <div class="input-group-modal">
                <input type="text" id="newSessionNameInput" placeholder="Nom de la nouvelle sÃ©ance" aria-label="Nom de la nouvelle sÃ©ance">
                <div id="newSessionNameError" class="error-message"></div>
            </div>
            <div style="display: flex; justify-content: center; gap: var(--spacing-md); margin-top: var(--spacing-lg);">
                <button class="btn btn-outline" id="cancelNewSessionBtn"><i class="fas fa-times" aria-hidden="true"></i> Annuler</button>
                <button class="btn btn-success" id="createNewSessionBtn"><i class="fas fa-check" aria-hidden="true"></i> CrÃ©er</button>
            </div>
        </div>
    </div>

    <div id="loadOptionsModal" class="modal-overlay hidden" role="dialog" aria-modal="true" aria-labelledby="loadOptionsModalTitle">
      <div class="modal-content">
          <button id="closeLoadOptionsModal" class="modal-close-btn" aria-label="Fermer le modal d'options de chargement">&times;</button>
          <h2 id="loadOptionsModalTitle">Options de Chargement</h2>
          <p>Comment utiliser la sÃ©ance "<strong id="loadSessionName"></strong>" ?</p>
          <div style="display: flex; justify-content: center; gap: var(--spacing-md); margin-top: var(--spacing-lg);">
              <button class="btn btn-primary" id="openNewSessionBtn"><i class="fas fa-folder-open" aria-hidden="true"></i> Ouvrir (remplace la sÃ©ance actuelle)</button>
              <button class="btn btn-secondary" id="appendToCurrentSessionBtn"><i class="fas fa-plus-square" aria-hidden="true"></i> Ajouter Ã  la sÃ©ance actuelle</button>
          </div>
      </div>
    </div>

    <div id="plateCalculatorModal" class="modal-overlay hidden" role="dialog" aria-modal="true" aria-labelledby="plateCalcModalTitle">
        <div class="modal-content">
            <button id="closePlateCalculatorModal" class="modal-close-btn" aria-label="Fermer le modal du calculateur de plaques">&times;</button>
            <div class="modal-tabs">
                <button class="modal-tab-btn active" id="plateCalcTab" aria-controls="plateCalcContent" role="tab" aria-selected="true">Calculateur de Plaques</button>
                <button class="modal-tab-btn" id="goalCalcTab" aria-controls="goalCalcContent" role="tab" aria-selected="false">Objectifs d'EntraÃ®nement</button>
            </div>
            
            <div id="plateCalcContent" class="modal-tab-content" role="tabpanel" aria-labelledby="plateCalcTab">
                <h2 id="plateCalcModalTitle">Calculateur de Plaques</h2>
                <div class="controls">
                    <div class="input-group-modal">
                        <input type="number" id="targetWeightInput" min="0" placeholder="Poids cible (kg)" aria-label="Poids cible">
                        <div id="targetWeightError" class="error-message"></div>
                    </div>
                    <div class="input-group-modal">
                        <input type="number" id="barbellWeightInput" min="0" placeholder="Poids barre (kg)" aria-label="Poids de la barre">
                        <div id="barbellWeightError" class="error-message"></div>
                    </div>
                </div>
                <div id="platesResult" style="text-align: left; margin-top: var(--spacing-lg);"></div>
            </div>

            <div id="goalCalcContent" class="modal-tab-content hidden" role="tabpanel" aria-labelledby="goalCalcTab">
                <h2>Objectifs d'EntraÃ®nement</h2>
                <div class="controls">
                    <div class="input-group-modal">
                        <input type="number" id="oneRmInput" min="0" placeholder="Votre 1RM (kg)" aria-label="Votre 1RM">
                        <div id="oneRmError" class="error-message"></div>
                    </div>
                </div>
                <div id="goalResultsContainer"></div>
            </div>
        </div>
    </div>
    
    <div id="quickEditModal" class="modal-overlay hidden" role="dialog" aria-modal="true" aria-labelledby="quickEditModalTitle">
      <div class="modal-content">
          <button id="closeQuickEditModal" class="modal-close-btn" aria-label="Fermer le modal d'Ã©dition rapide">&times;</button>
          <h2 id="quickEditModalTitle">Ãdition Rapide</h2>
          <p>Appliquer Ã  toutes les sÃ©ries de : <strong id="quickEditExerciseName"></strong></p>
          <div class="controls">
              <div class="input-group-modal">
                  <input type="text" id="quickEditWeight" placeholder="Poids (kg)" aria-label="Poids pour Ã©dition rapide">
                  <div id="quickEditWeightError" class="error-message"></div>
              </div>
              <div class="input-group-modal">
                  <input type="text" id="quickEditReps" placeholder="Reps" aria-label="RÃ©pÃ©titions pour Ã©dition rapide">
                  <div id="quickEditRepsError" class="error-message"></div>
              </div>
          </div>
          <button class="btn btn-success" id="applyQuickEditBtn" style="width: 100%; margin-top: var(--spacing-md);"><i class="fas fa-check-circle" aria-hidden="true"></i> Appliquer</button>
      </div>
    </div>

    <nav class="bottom-navigation">
        <button class="btn btn-primary" id="bottomAddExerciseBtn" aria-label="Ajouter un exercice">
            <i class="fas fa-plus-circle" aria-hidden="true"></i>
            <span>Exercice</span>
        </button>
        <button class="btn btn-primary" id="bottomNotesBtn" aria-label="Notes de sÃ©ance">
            <i class="fas fa-clipboard" aria-hidden="true"></i>
            <span>Notes</span>
        </button>
        <button class="btn btn-primary" id="bottomViewHistoryBtn" aria-label="Historique">
            <i class="fas fa-history" aria-hidden="true"></i>
            <span>Historique</span>
        </button>
        <button class="btn btn-primary" id="bottomPlateCalculatorBtn" aria-label="Calculateurs">
            <i class="fas fa-calculator" aria-hidden="true"></i>
            <span>Calculs</span>
        </button>
        <button class="btn btn-primary" id="bottomFinishSessionBtn" aria-label="Terminer la sÃ©ance">
            <i class="fas fa-flag-checkered" aria-hidden="true"></i>
            <span>Terminer</span>
        </button>
    </nav>

    <script>
    // PWA: Register Service Worker
    if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
        navigator.serviceWorker.register('/service-worker.js')
          .then(registration => {
            console.log('ServiceWorker registration successful with scope: ', registration.scope);
          })
          .catch(err => {
            console.log('ServiceWorker registration failed: ', err);
          });
      });
    }

    window.addEventListener('load', () => {

        const dom = {
            sessionSelect: document.getElementById('sessionSelect'),
            exerciseListContainer: document.getElementById('exerciseListContainer'), // Changed from tbody
            totalTonnageEl: document.getElementById('totalTonnage'),
            previousWeekInput: document.getElementById('previousWeek'),
            deltaEl: document.getElementById('delta'),
            totalTimeEl: document.getElementById('totalTime'),
            progressFill: document.getElementById('progressFill'),
            historyModal: document.getElementById('historyModal'),
            closeHistoryModal: document.getElementById('closeHistoryModal'), // FIX: Added missing DOM reference
            notificationContainer: document.getElementById('notification-container'),
            customExerciseInput: document.getElementById('customExercise'),
            addExerciseBtn: document.getElementById('addExerciseBtn'),
            historyList: document.getElementById('historyList'),
            importFileInput: document.getElementById('importFile'),
            themeToggleBtn: document.getElementById('themeToggleBtn'),
            body: document.body,
            toggleWorkoutTimerBtn: document.getElementById('toggleWorkoutTimerBtn'),
            newSessionModal: document.getElementById('newSessionModal'),
            closeNewSessionModal: document.getElementById('closeNewSessionModal'),
            newSessionNameInput: document.getElementById('newSessionNameInput'),
            cancelNewSessionBtn: document.getElementById('cancelNewSessionBtn'),
            createNewSessionBtn: document.getElementById('createNewSessionBtn'),
            createNewSessionTypeBtn: document.getElementById('createNewSessionTypeBtn'),
            deleteCurrentSessionBtn: document.getElementById('deleteCurrentSessionBtn'), // New DOM element
            loadOptionsModal: document.getElementById('loadOptionsModal'),
            closeLoadOptionsModal: document.getElementById('closeLoadOptionsModal'),
            loadSessionNameDisplay: document.getElementById('loadSessionName'),
            openNewSessionBtn: document.getElementById('openNewSessionBtn'),
            appendToCurrentSessionBtn: document.getElementById('appendToCurrentSessionBtn'),
            autocompleteSuggestions: document.getElementById('autocompleteSuggestions'),
            plateCalculatorModal: document.getElementById('plateCalculatorModal'),
            closePlateCalculatorModal: document.getElementById('closePlateCalculatorModal'),
            plateCalculatorBtn: document.getElementById('plateCalculatorBtn'),
            targetWeightInput: document.getElementById('targetWeightInput'),
            barbellWeightInput: document.getElementById('barbellWeightInput'),
            platesResult: document.getElementById('platesResult'),
            sessionNotesInput: document.getElementById('sessionNotes'),
            addExerciseSection: document.getElementById('addExerciseSection'),
            quickEditModal: document.getElementById('quickEditModal'),
            closeQuickEditModal: document.getElementById('closeQuickEditModal'),
            quickEditExerciseName: document.getElementById('quickEditExerciseName'),
            quickEditWeight: document.getElementById('quickEditWeight'),
            quickEditReps: document.getElementById('quickEditReps'),
            applyQuickEditBtn: document.getElementById('applyQuickEditBtn'),
            plateCalcTab: document.getElementById('plateCalcTab'),
            goalCalcTab: document.getElementById('goalCalcTab'),
            plateCalcContent: document.getElementById('plateCalcContent'),
            goalCalcContent: document.getElementById('goalCalcContent'),
            oneRmInput: document.getElementById('oneRmInput'),
            goalResultsContainer: document.getElementById('goalResultsContainer'),
            timerPlayPauseIcon: document.getElementById('timerPlayPauseIcon'),
            timerPlayPauseText: document.getElementById('timerPlayPauseText'),
            // New DOM elements for bottom navigation
            bottomAddExerciseBtn: document.getElementById('bottomAddExerciseBtn'),
            bottomFinishSessionBtn: document.getElementById('bottomFinishSessionBtn'),
            bottomViewHistoryBtn: document.getElementById('bottomViewHistoryBtn'),
            bottomPlateCalculatorBtn: document.getElementById('bottomPlateCalculatorBtn'),
            bottomNotesBtn: document.getElementById('bottomNotesBtn'), // New notes button
            sessionNotesSection: document.getElementById('sessionNotesSection'), // Notes section
            exportBtn: document.getElementById('exportBtn'),
            importBtn: document.getElementById('importBtn'),
            // New error message elements
            newSessionNameError: document.getElementById('newSessionNameError'),
            targetWeightError: document.getElementById('targetWeightError'),
            barbellWeightError: document.getElementById('barbellWeightError'),
            oneRmError: document.getElementById('oneRmError'),
            quickEditWeightError: document.getElementById('quickEditWeightError'),
            quickEditRepsError: document.getElementById('quickEditRepsError'),
            progressBar: document.getElementById('progressBar'),
            // PWA Install Prompt
            pwaInstallPrompt: document.getElementById('pwaInstallPrompt'),
            installPwaBtn: document.getElementById('installPwaBtn'),
            closePwaPrompt: document.getElementById('closePwaPrompt')
        };

        let state = {
            sessions: [], 
            currentSessionIndex: 0,
            timers: {},
            workoutStartTime: null,
            totalWorkoutTimeInterval: null,
            isWorkoutTimerPaused: false,
            pausedTime: 0,
            sessionToLoad: null,
            availableExercises: [],
            lastDeletedExercise: null,
            inactivityTimeout: null, 
            autoSaveInterval: null, 
            linkingState: { active: false, fromIndex: null }, 
            quickEditIndex: null,
            isMobileView: window.matchMedia("(max-width: 768px)").matches,
            isNotesSectionVisible: false, // New state for notes visibility
            deferredPwaPrompt: null // For PWA deferred prompt
        };
        
        const defaultSessions=[
            {name:"Haut du Corps (Force)",exercises:[
                { name:"DÃ©veloppÃ© couchÃ© barre",rest:"120s" },{ name:"Machine Ã©lÃ©vations latÃ©rales debout",rest:"" },{ name:"Tractions",rest:"90s" },{ name:"DÃ©veloppÃ© inclinÃ© haltÃ¨res",rest:"" },{ name:"Rowing T-barre appuyÃ©",rest:"90s" },{ name:"Pec Deck",rest:"" },{ name:"Curl inclinÃ© haltÃ¨res",rest:"75s" },{ name:"Extension triceps Ã  la poulie haute",rest:"" }
            ]},
            {name:"Bas du Corps (Force)",exercises:[
                { name:"SoulevÃ© de terre roumain (RDL)",rest:"120s" },{ name:"Hip thrust",rest:"120s" },{ name:"Hack squat",rest:"180s" },{ name:"Fentes bulgares",rest:"90s" },{ name:"Mollets debout",rest:"60s" }
            ]},
            {name:"Haut du Corps (Hypertrophie)",exercises:[
                { name:"Dips",rest:"90s" },{ name:"Tirage vertical prise large",rest:"" },{ name:"ÃcartÃ© inclinÃ© aux poulies",rest:"75s" },{ name:"Face Pull",rest:"" },{ name:"ÃlÃ©vations latÃ©rales Ã  la poulie",rest:"60s" },{ name:"Curl pupitre",rest:"75s" },{ name:"Extension triceps overhead",rest:"" },{ name:"Flexions poignets supination",rest:"60s" },{ name:"Extensions de poignets pronation",rest:"" },{ name:"Farmerâs Walk",rest:"90s" },{ name:"Planche",rest:"" }
            ]},
            {name:"Bas du Corps (Hypertrophie)",exercises:[
                { name:"Pendulum Squat",rest:"90s" },{ name:"Hip thrust",rest:"90s" },{ name:"Leg curl assis",rest:"75s" },{ name:"Mollets assis",rest:"60s" },{ name:"RelevÃ© fessier-ischio ",rest:"" },{ name:"Circuit abdos )",rest:"0s" }
            ]},
            {name:"TrapÃ¨zes & MobilitÃ© (Optionnel)",exercises:[
                { name:"Barbell Shrugs",rest:"60s" },{ name:"Face Pull",rest:"60s" },{ name:"Cable Y-Raise",rest:"60s" },{ name:"Dead Hang",rest:"60s" }
            ]}
        ];

        // List of default session names for checking if a session can be deleted
        const defaultSessionNames = defaultSessions.map(s => s.name);
        
        const rawExerciseList = `
ABS rolls,Abdos couchÃ©,Abducteurs,Adducteurs,Adduction poulie jambe pliÃ©e,Archer row,Arnold press,Ball slam,Ball slam cÃ´tÃ©,Bar hang,Bayesian curl,Bear push up,Biceps anneaux,Biceps-triceps extension superset,Bird dog,Bobine d'Andrieu,Bobine d'Andrieu inversÃ©e,Brignole cable press down,Brignole squat,Burpees,Cable crunch,Cable extension jambe,Cable glute kickback,Cable jambe Ã©tendue,Cable kickback,Cable leg extension,Cable press down,Cable cable press down brignole,Calf raise machine,Cat camel,Chest flies,Chest flies machine,Circuit cross training,Corde Ã  sauter,Course sur tapis,Crunch,Crunch classique,Curl barre EZ,Curl inclinÃ©,Curl marteau assis,Curl pronation,Curl pronation haltÃ¨res,Curl pupitre,Curl pupitre machine,Deadbug,Deadlift trap bar,Dips,Dips pectoraux anneaux,Dips verticaux barres fixes,Donkey kick,Drapeau humain,Drop jump single leg,DÃ©v. couchÃ© partiel prise serrÃ©e,DÃ©v. inclinÃ©,DÃ©v. militaire assis haltÃ¨res,DÃ©veloppÃ© couchÃ©,DÃ©veloppÃ© couchÃ© haltÃ¨res,DÃ©veloppÃ© couchÃ© inclinÃ© haltÃ¨res,DÃ©veloppÃ© devant landmine,DÃ©veloppÃ© militaire,DÃ©veloppÃ© militaire barre,DÃ©veloppÃ© militaire haltÃ¨re,Elevations tibialis,Extension haltÃ¨res en hauteur,Extension triceps corde,Extension triceps Ã©lastique,Facepull,Facepull anneaux,Fentes bulgares,Fentes marchÃ©es,Flexion haltÃ¨res en hauteur,Floor press haltÃ¨res,Fly au sol bras Ã  60Â°,Front Squats,Front lever,Gainage rÃ©troversion,Glute bridge,Glute extension,Glute ham raise,Glute kickback,High lat pull in,Hip thrust une jambe,Hula hoop,Inverted row,Jump squats,Jumping jacks,L-Fly,L-fly poulie,L-fly Ã©lastique,Landmine press,Landmine squat,Landmine squeeze press,Lat prayer,Leg curl allongÃ©,Leg curl assis,Leg curl delavier,Leg curl haltÃ¨res,Leg curl machine,Leg extension,Machine arriÃ¨re Ã©paules,Machine rowing divergent,Magyc triceps,Masse de force,ForceMedecine ball wall slam,Medicine ball wall slam,Modified row,Mollets assis,Mollets assis barre,Mollets assis machine,Mollets debout,Mollets machine,Mollets Ã  la barre guidÃ©e,Mollets Ã  la presse Ã  cuisse,MontÃ©e de marches,Mountain climbers,Multi-hip,Musclets,Nordic hamstring,Oiseau,Oiseau poulie/anneaux,Oiseaux poulie,Pec deck,Pendlay row,Pistol assistÃ©,Plank,Pompes archer,Pompes complÃ¨tes,Pompes pliomÃ©triques,Pompes sur anneaux,PortÃ©e de grosse pierre,PoussÃ©e de poulie diagonale haute,PoussÃ©e de rouleau dans le mur,Presse Palof,Presse inclinÃ©e,Pull over haltÃ¨res,Rack push,RelevÃ© de jambes suspendu,RetournÃ© de pneu,Romanian Deadlift,Romanian deadlift,Rowing Yates,Rowing bÃ»cheron,Rowing divergent,Rowing haltÃ¨res,Rowing uneven,Side bend,Side bend Ã©lastique,Side plank dynamique,Single leg hipthrust landmine,Single leg stiff leg deadlift,Sissy Mathias,Sissy squat,Sissy squat anneaux,Sissy squat appui anneaux,Sissy squat machine,Skull crusher,Sled push,Sprint,Sprint en montÃ©e,Squat barre,Squat talons trÃ¨s relevÃ©s,Standing cable leg curl,Step up,Step up accrochÃ©,Superman,Superset Crunch/relevÃ© de jambes,Swing kettlebell + Ã©lastique,Swings,Tibialis anterior,Tirage arrachÃ©,Tirage horizontal,Tirage vertical machine,Tirage vertical unilatÃ©ral,Tire flip,Traction assistÃ©e,Traction supination,Tractions anneaux,Tractions porte,Tractions prise neutre focus coude,Tractions pronation,Tractions pronation prise serrÃ©e,Tractions scapulaires,Tractions scapulaires uneven,Tractions supination,Triceps anneaux,Triceps au mur,Triceps poulie,Unilateral lat pull in,Upright row,Wall ball,Wall ball devant,Wall ball diagonal,Wall ball frisbee,Woodchopper,ÃcartÃ© couchÃ© haltÃ¨res,ÃcartÃ© poulie haute,ÃlÃ©vation frontale,ÃlÃ©vations latÃ©rales,ÃlÃ©vations latÃ©rales couchÃ©es,ÃlÃ©vations latÃ©rales poulie,ÃlÃ©vations latÃ©rales unilatÃ©rale,ÃlÃ©vations mollets debout
        `.split(',').map(item => item.trim());
        
        // ===================================================================
        // ALL FUNCTION DEFINITIONS
        // ===================================================================

        // PWA Install Prompt Handling
        window.addEventListener('beforeinstallprompt', (e) => {
            e.preventDefault();
            state.deferredPwaPrompt = e;
            // Only show the prompt if it hasn't been dismissed before
            if (localStorage.getItem('pwaPromptDismissed') !== 'true') {
                dom.pwaInstallPrompt.classList.remove('hidden');
                setTimeout(() => dom.pwaInstallPrompt.classList.add('show'), 10);
            }
        });

        dom.installPwaBtn.addEventListener('click', async () => {
            if (state.deferredPwaPrompt) {
                state.deferredPwaPrompt.prompt();
                const { outcome } = await state.deferredPwaPrompt.userChoice;
                console.log(`User response to the install prompt: ${outcome}`);
                if (outcome === 'accepted') {
                    showNotification('Lyftiv a Ã©tÃ© ajoutÃ© Ã  votre Ã©cran d\'accueil!', 'success', 5000);
                }
                state.deferredPwaPrompt = null;
                dom.pwaInstallPrompt.classList.remove('show');
                dom.pwaInstallPrompt.addEventListener('transitionend', () => dom.pwaInstallPrompt.classList.add('hidden'), { once: true });
            }
        });

        dom.closePwaPrompt.addEventListener('click', () => {
            dom.pwaInstallPrompt.classList.remove('show');
            dom.pwaInstallPrompt.addEventListener('transitionend', () => dom.pwaInstallPrompt.classList.add('hidden'), { once: true });
            localStorage.setItem('pwaPromptDismissed', 'true'); // Remember dismissal
        });
        
        /**
         * Validates an input field for numerical correctness and applies/removes error styling.
         * @param {HTMLElement} inputElement The input element to validate.
         * @param {HTMLElement} errorDisplayElement The element to display error messages.
         * @param {boolean} allowEmpty If true, empty input is considered valid.
         * @returns {boolean} True if the input is valid, false otherwise.
         */
        function validateInputField(inputElement, errorDisplayElement, allowEmpty = false) {
            const value = inputElement.value.trim();
            if (allowEmpty && value === '') {
                inputElement.classList.remove('is-invalid');
                errorDisplayElement.textContent = '';
                return true;
            }
            // Regex to allow integers and decimals with at most two decimal places.
            const regex = /^\d+(\.\d{1,2})?$/;
            if (!regex.test(value) || parseFloat(value) < 0) {
                inputElement.classList.add('is-invalid');
                errorDisplayElement.textContent = 'Veuillez entrer un nombre positif valide.';
                return false;
            } else {
                inputElement.classList.remove('is-invalid');
                errorDisplayElement.textContent = '';
                return true;
            }
        }

        function handleRepInput(e) {
            const input = e.target;
            // Allow multiple values separated by '+'
            let value = input.value.replace(/,/g, '.'); // Replace commas with dots
            // Validate each segment
            const segments = value.split('+').map(s => s.trim());
            const validatedSegments = segments.filter(s => {
                if (s === '') return true; // Allow empty segments for partial input
                const num = parseFloat(s);
                return !isNaN(num) && num >= 0;
            });
            input.value = validatedSegments.join('+');
        }

        function getPlateCombinationOptimal(target, denominations) {
            let currentRemaining = target;
            const platesUsed = {};
            let loadedWeight = 0;
            for (const plateValue of denominations) {
                const numPlates = Math.floor(currentRemaining / plateValue);
                if (numPlates > 0) {
                    platesUsed[plateValue] = numPlates;
                    loadedWeight += numPlates * plateValue;
                    currentRemaining -= (numPlates * plateValue);
                    currentRemaining = parseFloat(currentRemaining.toFixed(2)); 
                }
            }
            return { plates: platesUsed, loadedWeight: loadedWeight, remaining: currentRemaining };
        }

        function getPlateCombinationAlternative(target, fullDenominations) {
            let currentRemaining = target;
            const platesUsed = {};
            // Exclude 25kg and 15kg plates from the alternative order
            const alternativeOrder = [20, 10, 5, 2.5, 1.25, 0.5, 0.25]; 
            const availableAlternativeOrder = fullDenominations.filter(p => alternativeOrder.includes(p));
            // Sort available alternative denominations in descending order
            availableAlternativeOrder.sort((a, b) => b - a);

            for (const plateValue of availableAlternativeOrder) {
                if (currentRemaining <= 0) break; 
                const numPlates = Math.floor(currentRemaining / plateValue);
                if (numPlates > 0) {
                    platesUsed[plateValue] = (platesUsed[plateValue] || 0) + numPlates;
                    currentRemaining -= numPlates * plateValue;
                    currentRemaining = parseFloat(currentRemaining.toFixed(2)); 
                }
            }
            let loadedWeight = target - currentRemaining; 
            return { plates: platesUsed, loadedWeight: loadedWeight, remaining: currentRemaining };
        }


        function formatPlatesWithPlus(platesObject) {
            let formatted = [];
            const sortedPlateValues = Object.keys(platesObject).map(Number).sort((a, b) => b - a);
            for (const plateValue of sortedPlateValues) {
                if (platesObject[plateValue] > 0) {
                    formatted.push(`<span>${plateValue}kg x${platesObject[plateValue]}</span>`); 
                }
            }
            return formatted.length > 0 ? formatted.join(' + ') : 'Aucun';
        }
        
        // [FIX #3] - Modified plate calculator logic
        function calculatePlates() {
            const targetValid = validateInputField(dom.targetWeightInput, dom.targetWeightError);
            const barbellValid = validateInputField(dom.barbellWeightInput, dom.barbellWeightError);

            if (!targetValid || !barbellValid) {
                dom.platesResult.innerHTML = `<p class="plate-result-message danger">Veuillez corriger les erreurs dans les poids.</p>`;
                return;
            }

            const targetWeight = parseFloat(dom.targetWeightInput.value);
            const barbellWeight = parseFloat(dom.barbellWeightInput.value);
            
            if (barbellWeight > targetWeight) {
                dom.targetWeightInput.classList.add('is-invalid');
                dom.targetWeightError.textContent = 'Le poids cible doit Ãªtre supÃ©rieur ou Ã©gal au poids de la barre.';
                dom.platesResult.innerHTML = `<p class="plate-result-message danger">Veuillez corriger les erreurs dans les poids.</p>`;
                return;
            } else {
                dom.targetWeightInput.classList.remove('is-invalid');
                dom.targetWeightError.textContent = '';
            }


            let weightPerSideTarget = (targetWeight - barbellWeight) / 2;
            
            const platesDenominations = [25, 20, 15, 10, 5, 2.5, 1.25, 0.5, 0.25].sort((a, b) => b - a);

            const combinationResult1 = getPlateCombinationOptimal(weightPerSideTarget, platesDenominations);
            const combinationResult2 = getPlateCombinationAlternative(weightPerSideTarget, platesDenominations);
            
            // Calculate total plates for BOTH sides
            const totalPlates1 = {};
            for (const plate in combinationResult1.plates) {
                totalPlates1[plate] = combinationResult1.plates[plate] * 2;
            }
            const formattedTotalPlates1 = formatPlatesWithPlus(totalPlates1);
            
            const totalPlates2 = {};
            for (const plate in combinationResult2.plates) {
                totalPlates2[plate] = combinationResult2.plates[plate] * 2;
            }
            const formattedTotalPlates2 = formatPlatesWithPlus(totalPlates2);

            const loadedWeightPerSide = combinationResult1.loadedWeight;
            const totalLoadedWeight = loadedWeightPerSide * 2 + barbellWeight;
            const diff = targetWeight - totalLoadedWeight;

            let resultHtml = `<div class="result-summary">
                                <h3>RÃ©sultats :</h3>
                                <p>Poids chargÃ© par cÃ´tÃ©: <span>${loadedWeightPerSide.toFixed(2)}kg</span> | Poids total chargÃ©: <span>${totalLoadedWeight.toFixed(2)}kg</span></p>`;
            
            if (Math.abs(diff) < 0.01) {
                resultHtml += `<p class="plate-result-message success">Poids cible atteint !</p>`;
            } else {
                resultHtml += `<p class="plate-result-message danger">DiffÃ©rence par rapport Ã  la cible: ${diff > 0 ? '+' : ''}${diff.toFixed(2)}kg</p>`;
            }
            resultHtml += `</div>`;
            resultHtml += `<h4>1. Total des plaques (2 cÃ´tÃ©s) - Minimisant le nombre:</h4><p>${formattedTotalPlates1}</p>`;
            if(formattedTotalPlates1 !== formattedTotalPlates2 && formattedTotalPlates2 !== 'Aucun') {
                resultHtml += `<h4>2. Total des plaques (2 cÃ´tÃ©s) - Autre dÃ©composition:</h4><p>${formattedTotalPlates2}</p>`;
            }
            
            dom.platesResult.innerHTML = resultHtml;
        }

        function calculateTrainingGoals() {
            const oneRmValid = validateInputField(dom.oneRmInput, dom.oneRmError);
            if (!oneRmValid) {
                dom.goalResultsContainer.innerHTML = '';
                return;
            }

            const oneRm = parseFloat(dom.oneRmInput.value);

            // Updated goals array with new order and Phosphor Icons
            const goals = [
                { name: 'Hypertrophie', icon: '<i class="ph-fill ph-person"></i>', minPercent: 0.60, maxPercent: 0.80, a_class: 'hypertrophy', tooltip: '60-80% du 1RM', reps: '6-12 RÃ©pÃ©titions' },
                { name: 'Force', icon: '<i class="ph-fill ph-barbell"></i>', minPercent: 0.80, maxPercent: 1.00, a_class: 'strength', tooltip: '80-100% du 1RM', reps: '1-5 RÃ©pÃ©titions' },
                { name: 'Endurance', icon: '<i class="ph-fill ph-fire"></i>', minPercent: 0, maxPercent: 0.60, a_class: 'endurance', tooltip: '<60% du 1RM', reps: '15+ RÃ©pÃ©titions' },
                { name: 'Power', icon: '<i class="ph-fill ph-lightning"></i>', minPercent: 0.30, maxPercent: 0.70, a_class: 'power', tooltip: '30-70% du 1RM', reps: '3-6 RÃ©pÃ©titions (explosif)' }
            ];

            let resultsHtml = '';
            goals.forEach(goal => {
                const minWeight = (oneRm * goal.minPercent).toFixed(1);
                const maxWeight = (oneRm * goal.maxPercent).toFixed(1);
                let rangeText;
                if (goal.minPercent === 0) {
                    rangeText = `< ${maxWeight} kg`;
                } else {
                    rangeText = `${minWeight} - ${maxWeight} kg`;
                }

                resultsHtml += `
                    <div class="goal-card ${goal.a_class}" title="${goal.tooltip}">
                        <h4><span class="icon">${goal.icon}</span> ${goal.name}</h4>
                        <div class="weight-range">${rangeText}</div>
                        <p class="rep-range">${goal.reps}</p>
                    </div>
                `;
            });

            dom.goalResultsContainer.innerHTML = resultsHtml;
        }
        
        async function handleTableActions(e) {
            const button = e.target.closest('button');
            if (!button) return;
            const rowOrCard = button.closest('.exercise-row') || button.closest('.exercise-card');
            if (!rowOrCard) return;
            const idx = +rowOrCard.dataset.exerciseIndex;
            const timerAction = button.dataset.timerAction;
            const action = button.dataset.action;

            if (action === 'quick-edit') {
                state.quickEditIndex = idx;
                dom.quickEditExerciseName.textContent = state.sessions[state.currentSessionIndex].exercises[idx].name;
                dom.quickEditModal.classList.remove('hidden');
                dom.quickEditModal.classList.add('show');
                // Set focus to the first input field in the quick edit modal
                dom.quickEditWeight.focus();
                // Clear any previous error messages
                dom.quickEditWeight.classList.remove('is-invalid');
                dom.quickEditWeightError.textContent = '';
                dom.quickEditReps.classList.remove('is-invalid');
                dom.quickEditRepsError.textContent = '';
            } else if (action === 'link-superset') {
                const exercises = state.sessions[state.currentSessionIndex].exercises;
                const clickedExercise = exercises[idx];

                // Case 1: Clicked an already-linked exercise -> UNLINK
                if (clickedExercise.supersetGroup) {
                    let partnerIndex = -1;
                    // Find partner
                    if (clickedExercise.supersetWith !== null && clickedExercise.supersetWith !== undefined) {
                        partnerIndex = clickedExercise.supersetWith;
                    } else {
                        const partner = exercises.find(e => e.supersetWith === idx);
                        if (partner) {
                            partnerIndex = exercises.indexOf(partner);
                            partner.supersetWith = null; // Unlink partner
                        }
                    }
                    // Unlink both
                    clickedExercise.supersetWith = null;
                    clickedExercise.supersetGroup = false;
                    if (partnerIndex !== -1) {
                        exercises[partnerIndex].supersetGroup = false;
                    }
                    showNotification("Superset dÃ©liÃ©.", "info");

                    // If we were in the middle of linking something else, cancel it
                    if (state.linkingState.active) {
                        state.linkingState = { active: false, fromIndex: null };
                    }
                    createTable(); // Rerender
                }
                // Case 2: Clicked an un-linked exercise
                else {
                    // Subcase 2a: Not currently linking -> START linking
                    if (!state.linkingState.active) {
                        state.linkingState.active = true;
                        state.linkingState.fromIndex = idx;
                        button.classList.add('linking'); // Temporary class for visual feedback
                        showNotification(`SÃ©lectionnez un autre exercice Ã  lier avec "${clickedExercise.name}".`, "info");
                    }
                    // Subcase 2b: Currently linking -> COMPLETE link
                    else {
                        const fromIndex = state.linkingState.fromIndex;
                        if (fromIndex !== idx) { // Can't link to itself
                            // Link fromIndex to idx
                            exercises[fromIndex].supersetWith = idx;
                            exercises[fromIndex].supersetGroup = true;
                            clickedExercise.supersetGroup = true;

                            // Unset old links if the target was already part of another superset
                            const oldLink = exercises.find((e, i) => e.supersetWith === idx && i !== fromIndex);
                            if (oldLink) {
                                oldLink.supersetWith = null;
                                oldLink.supersetGroup = false;
                            }

                            showNotification("Exercices liÃ©s en superset!", "success");
                        }
                        // Reset state and rerender
                        state.linkingState = { active: false, fromIndex: null };
                        createTable();
                    }
                }
            } else if (timerAction) {
                handleTimerActions(timerAction, idx, rowOrCard);
            } else if (action === 'remove') {
                const exerciseToRemove = state.sessions[state.currentSessionIndex].exercises[idx];
                const confirmed = await customConfirm(`Ãtes-vous sÃ»r de vouloir supprimer l'exercice "${exerciseToRemove.name}"?`);
                if (confirmed) {
                    state.sessions[state.currentSessionIndex].exercises.splice(idx, 1);
                    state.lastDeletedExercise = exerciseToRemove;
                    if (state.timers[idx]) {
                        clearInterval(state.timers[idx].interval);
                        delete state.timers[idx];
                    }
                    createTable();
                    showUndoableNotification(`Exercice "${exerciseToRemove.name}" supprimÃ©.`, () => {
                        if (state.lastDeletedExercise) {
                            state.sessions[state.currentSessionIndex].exercises.splice(idx, 0, state.lastDeletedExercise);
                            createTable();
                            updateAllTotals();
                            state.lastDeletedExercise = null;
                            showNotification(`Suppression annulÃ©e. "${exerciseToRemove.name}" restaurÃ©.`, "info");
                        }
                    }, 7000);
                }
            } else if (button.classList.contains('serie-input-delete')) { // New series delete action
                const exIndex = +button.dataset.ex;
                const serieIndex = +button.dataset.serie;
                const weightInput = document.querySelector(`[data-ex='${exIndex}'][data-serie='${serieIndex}'].weight`);
                const repsInput = document.querySelector(`[data-ex='${exIndex}'][data-serie='${serieIndex}'].reps`);
                if (weightInput) {
                    weightInput.value = '';
                    weightInput.classList.remove('is-invalid'); // Clear validation
                }
                if (repsInput) {
                    repsInput.value = '';
                    repsInput.classList.remove('is-invalid'); // Clear validation
                }
                updateAllTotals(); // Recalculate totals after clearing
                showNotification(`SÃ©rie ${serieIndex + 1} de l'exercice effacÃ©e.`, "info", 2000);
            }
        }
        
        // [FIX #1] - Modified timer logic
        function handleTimerActions(timerAction, idx, element) { // element can be row or card
             const timerDisplay = element.querySelector('.timer-display');
             const startBtn = element.querySelector('[data-timer-action="start"]');
             const stopBtn = element.querySelector('[data-timer-action="stop"]');
             const resetBtn = element.querySelector('[data-timer-action="reset"]'); // Get reset button
             const exercise = state.sessions[state.currentSessionIndex].exercises[idx];
             const restString = exercise.rest;
             let restSeconds = parseInt(restString) * (restString.includes('min') ? 60 : 1) || 60;
             const duration = Math.max(restSeconds, 60); 

            if (timerAction === 'start') {
                // Save timer state to localStorage for persistence across page exits
                localStorage.setItem(`timer-${idx}`, JSON.stringify({
                    endTime: Date.now() + duration * 1000,
                    name: exercise.name,
                    startTime: Date.now(),
                    duration: duration // Added duration for persistence
                }));
                
                if (state.timers[idx] && state.timers[idx].interval) clearInterval(state.timers[idx].interval);
                state.timers[idx] = {
                    secondsElapsed: 0,
                    duration: duration,
                    interval: setInterval(() => {
                        state.timers[idx].secondsElapsed++;
                        const remaining = state.timers[idx].duration - state.timers[idx].secondsElapsed;
                        if (remaining <= 0) {
                            timerDisplay.textContent = formatTimerDisplay(0); // Show 0:00 when finished
                            timerDisplay.classList.remove('timer-active');
                            clearInterval(state.timers[idx].interval);
                            localStorage.removeItem(`timer-${idx}`);
                            playBeep(); 
                            if(Notification.permission === "granted") {
                                new Notification('Lyftiv - Repos TerminÃ© !', { body: `Le temps de repos pour ${exercise.name} est terminÃ©.`});
                            }
                            // Reset state for buttons
                            startBtn.classList.remove('hidden'); 
                            stopBtn.classList.add('hidden'); 
                            
                            // NEW SUPERSET LOGIC
                            const exercises = state.sessions[state.currentSessionIndex].exercises;
                            const parentIndex = exercises.findIndex(ex => ex.supersetWith === idx);
                            if (parentIndex !== -1) {
                                const parentExercise = exercises[parentIndex];
                                const parentElement = document.querySelector(`[data-exercise-index="${parentIndex}"]`);
                                parentElement?.classList.add('next-superset-exercise');
                                showNotification(`Fin du repos ! Reprenez avec ${parentExercise.name}`, "info");
                            }

                        } else {
                            timerDisplay.textContent = formatTimerDisplay(remaining); 
                        }
                    }, 1000) 
                };
                timerDisplay.textContent = formatTimerDisplay(duration); 
                timerDisplay.classList.add('timer-active'); 
                startBtn.classList.add('hidden'); 
                stopBtn.classList.remove('hidden'); 
            } else if (timerAction === 'stop' || timerAction === 'reset') {
                if (state.timers[idx] && state.timers[idx].interval) clearInterval(state.timers[idx].interval);
                localStorage.removeItem(`timer-${idx}`);
                state.timers[idx] = null; 
                timerDisplay.classList.remove('timer-active'); 
                timerDisplay.textContent = formatTimerDisplay(duration); // Always reset to full duration
                startBtn.classList.remove('hidden'); 
                stopBtn.classList.add('hidden'); 
            }
        }

        async function handleHistoryActions(e) { 
            const button = e.target.closest('button');
            if (!button) return;
            const historyAction = button.dataset.historyAction;
            const historyId = +button.dataset.historyId;
            if (historyAction === 'details') showHistoryDetails(historyId);
            else if (historyAction === 'delete') await deleteHistoryItem(historyId);
            else if (historyAction === 'load') {
                const historicalSession = getHistory().find(s => s.id == historyId);
                if (historicalSession) {
                    showLoadOptionsModal(historicalSession); 
                } else {
                    showNotification("La sÃ©ance historique demandÃ©e n'a pas Ã©tÃ© trouvÃ©e.", "error");
                }
            }
        }

        async function deleteHistoryItem(id) {
            const confirmed = await customConfirm("Ãtes-vous sÃ»r de vouloir supprimer dÃ©finitivement cette sÃ©ance de l'historique ?");
            if (confirmed) {
                let history = getHistory().filter(session => session.id != id);
                localStorage.setItem('workoutHistory', JSON.stringify(history));
                displayHistory(); 
                showNotification("SÃ©ance supprimÃ©e de l'historique avec succÃ¨s.", "info");
            }
        }
        
        function updateStateFromTable() {
            const currentSession = state.sessions[state.currentSessionIndex];
            if (!currentSession || !currentSession.exercises) return;

            currentSession.exercises.forEach((ex, idx) => {
                if (!ex.series) {
                    ex.series = [];
                }
                for (let i = 0; i < 5; i++) {
                    // Select inputs based on current view (table or card)
                    const weightInput = document.querySelector(`[data-ex='${idx}'][data-serie='${i}'].weight`);
                    const repsInput = document.querySelector(`[data-ex='${idx}'][data-serie='${i}'].reps`);
                    
                    if (weightInput && repsInput) {
                        if (!ex.series[i]) {
                            ex.series[i] = {};
                        }
                        ex.series[i].weight = weightInput.value;
                        ex.series[i].reps = repsInput.value;
                    }
                }
            });
        }
        
        function createTable() {
            dom.exerciseListContainer.innerHTML = "";
            const exercises = state.sessions[state.currentSessionIndex]?.exercises || []; 

            if (!state.isMobileView) {
                // Desktop view: render as table
                const table = document.createElement("table");
                table.id = "workoutTable";
                table.className = "desktop-table"; // Add class for desktop styling
                table.setAttribute('role', 'table');
                table.setAttribute('aria-label', 'Liste des exercices de la sÃ©ance');

                const thead = document.createElement("thead");
                thead.innerHTML = `
                    <tr role="row">
                        <th class="actions-col" scope="col">Actions</th>
                        <th scope="col">Exercice</th>
                        <th colspan="5" scope="colgroup">SÃ©ries</th>
                        <th scope="col">Tonnage</th>
                        <th scope="col">1RM</th>
                        <th scope="col">Repos</th>
                        <th scope="col">Minuteur</th>
                        <th scope="col"></th> 
                    </tr>
                `;
                table.appendChild(thead);

                const tbody = document.createElement("tbody");
                tbody.id = "tbody"; // Keep tbody ID for existing event listeners
                table.appendChild(tbody);
                dom.exerciseListContainer.appendChild(table);

                exercises.forEach((ex, idx) => {
                    const tr = document.createElement("tr");
                    tr.className = "exercise-row";
                    tr.dataset.exerciseIndex = idx;
                    tr.setAttribute('role', 'row');
            
                    // Superset group visual indication
                    if (ex.supersetGroup) {
                        tr.classList.add('superset-group');
                    }

                    let seriesContentHtml = "";
                    for(let i = 0; i < 5; i++) {
                        const currentSeries = ex.series?.[i] || {};
                        seriesContentHtml += `<td role="cell"><div class="serie-input">
                            <input type="text" data-ex="${idx}" data-serie="${i}" class="weight" placeholder="kg" aria-label="Poids pour l'exercice ${ex.name} sÃ©rie ${i+1}" value="${currentSeries.weight || ''}" tabindex="${(idx * 10) + (i * 2) + 1}">
                            <input type="text" data-ex="${idx}" data-serie="${i}" class="reps" placeholder="Reps" aria-label="Reps pour l'exercice ${ex.name} sÃ©rie ${i+1}" value="${currentSeries.reps || ''}" tabindex="${(idx * 10) + (i * 2) + 2}">
                            <button class="serie-input-delete" data-ex="${idx}" data-serie="${i}" aria-label="Effacer cette sÃ©rie">&times;</button>
                        </div></td>`;
                    }
                    
                    tr.innerHTML = `
                        <td class="actions-col" data-label="Actions" role="cell">
                            <button class="quick-edit-btn tooltip" data-action="quick-edit" aria-label="Ãdition rapide pour ${ex.name}">
                                <i class="fas fa-pencil-alt" aria-hidden="true"></i>
                                <span class="tooltiptext">Ãdition rapide</span>
                            </button>
                            <button class="link-btn tooltip" data-action="link-superset" aria-label="Lier ${ex.name} pour superset">
                                <i class="fas fa-link" aria-hidden="true"></i>
                                <span class="tooltiptext">Lier Superset</span>
                            </button>
                        </td>
                        <td class="exercise-col" data-label="Exercice" title="${ex.name}" role="cell">
                            <span>${ex.name}</span>
                        </td>
                        ${seriesContentHtml}
                        <td data-label="Tonnage" id="tonnage-${idx}" role="cell">0</td>
                        <td data-label="1RM" id="onerm-${idx}" role="cell">0</td>
                        <td data-label="Repos" role="cell"><strong>${ex.rest}</strong></td>
                        <td data-label="Minuteur" role="cell">
                            <div class="timer-container">
                                <div class="timer-display" id="timer-${idx}" aria-live="polite">0:00</div>
                                <button class="timer-btn" data-timer-action="start" aria-label="DÃ©marrer le minuteur pour ${ex.name}"><i class="fas fa-play" aria-hidden="true"></i></button>
                                <button class="timer-btn hidden" data-timer-action="stop" aria-label="ArrÃªter le minuteur pour ${ex.name}"><i class="fas fa-stop" aria-hidden="true"></i></button>
                                <button class="timer-btn" data-timer-action="reset" aria-label="RÃ©initialiser le minuteur pour ${ex.name}"><i class="fas fa-redo" aria-hidden="true"></i></button>
                            </div>
                        </td>
                        <td role="cell"><button class="btn-ghost" data-action="remove" aria-label="Supprimer l'exercice ${ex.name}"><i class="fas fa-trash-alt" aria-hidden="true"></i></button></td>`;
                    tbody.appendChild(tr);
                    
                    // Apply active class to button for persistent state
                    if (ex.supersetGroup) {
                        const linkBtn = tr.querySelector('.link-btn');
                        if (linkBtn) linkBtn.classList.add('active-superset');
                    }
                });
            } else {
                // Mobile view: render as cards
                const mobileCardsContainer = document.createElement("div");
                mobileCardsContainer.className = "mobile-cards";
                mobileCardsContainer.setAttribute('role', 'list');
                dom.exerciseListContainer.appendChild(mobileCardsContainer);

                exercises.forEach((ex, idx) => {
                    const card = document.createElement("div");
                    card.className = "exercise-card";
                    card.dataset.exerciseIndex = idx;
                    card.setAttribute('role', 'listitem');
                    card.setAttribute('aria-label', `Exercice: ${ex.name}`);

                    // Superset group visual indication
                    if (ex.supersetGroup) {
                         card.classList.add('superset-group');
                    }

                    let seriesHtml = '';
                    for (let i = 0; i < 5; i++) {
                        const currentSeries = ex.series?.[i] || {};
                        seriesHtml += `
                            <div class="series-row">
                                <span>SÃ©rie ${i + 1}:</span>
                                <div class="series-input-group">
                                    <input type="text" data-ex="${idx}" data-serie="${i}" class="weight" placeholder="kg" aria-label="Poids pour l'exercice ${ex.name} sÃ©rie ${i+1}" value="${currentSeries.weight || ''}" tabindex="${(idx * 10) + (i * 2) + 1}">
                                    <input type="text" data-ex="${idx}" data-serie="${i}" class="reps" placeholder="Reps" aria-label="Reps pour l'exercice ${ex.name} sÃ©rie ${i+1}" value="${currentSeries.reps || ''}" tabindex="${(idx * 10) + (i * 2) + 2}">
                                    <button class="serie-input-delete" data-ex="${idx}" data-serie="${i}" aria-label="Effacer sÃ©rie ${i+1} pour ${ex.name}">&times;</button>
                                </div>
                            </div>
                        `;
                    }

                    card.innerHTML = `
                        <h4>
                            ${ex.name}
                            <button class="btn-ghost" data-action="remove" aria-label="Supprimer l'exercice ${ex.name}"><i class="fas fa-trash-alt" aria-hidden="true"></i></button>
                        </h4>
                        <div class="series-group">
                            ${seriesHtml}
                        </div>
                        <div class="card-stats">
                            <div class="card-stat-item">
                                <span class="card-stat-label">Tonnage</span>
                                <span class="card-stat-value" id="tonnage-${idx}">0</span>
                            </div>
                            <div class="card-stat-item">
                                <span class="card-stat-label">1RM Moy</span>
                                <span class="card-stat-value" id="onerm-${idx}">0</span>
                            </div>
                            <div class="card-stat-item">
                                <span class="card-stat-label">Repos</span>
                                <span class="card-stat-value">${ex.rest}</span>
                            </div>
                        </div>
                        <div class="card-actions">
                            <button class="btn btn-info" data-action="quick-edit" aria-label="Ãdition rapide pour ${ex.name}"><i class="fas fa-pencil-alt" aria-hidden="true"></i> Ãditer</button>
                            <button class="btn btn-secondary link-btn" data-action="link-superset" aria-label="Lier ${ex.name} pour superset"><i class="fas fa-link" aria-hidden="true"></i> Superset</button>
                            <div class="timer-container">
                                <div class="timer-display" id="timer-${idx}" aria-live="polite">0:00</div>
                                <button class="timer-btn" data-timer-action="start" aria-label="DÃ©marrer le minuteur pour ${ex.name}"><i class="fas fa-play" aria-hidden="true"></i></button>
                                <button class="timer-btn hidden" data-timer-action="stop" aria-label="ArrÃªter le minuteur pour ${ex.name}"><i class="fas fa-stop" aria-hidden="true"></i></button>
                                <button class="timer-btn" data-timer-action="reset" aria-label="RÃ©initialiser le minuteur pour ${ex.name}"><i class="fas fa-redo" aria-hidden="true"></i></button>
                            </div>
                        </div>
                    `;
                    mobileCardsContainer.appendChild(card);
                    
                    // Apply active class to button for persistent state
                    if (ex.supersetGroup) {
                        const linkBtn = card.querySelector('.link-btn');
                        if (linkBtn) linkBtn.classList.add('active-superset');
                    }
                });
            }

            loadCurrentState();
            updateAllTotals();
            updateDeleteSessionButtonState(); // Update state of delete session button
        }

        function calculate1RM(weight, reps) {
            if (reps <= 0 || weight <= 0) return 0;
            // Brzycki formula
            const brzycki1RM = weight / (1.0278 - (0.0278 * reps));
            // Mayhew formula (common for 1RM estimations)
            const mayhew1RM = (100 * weight) / (52.2 + (41.9 * Math.exp(-0.055 * reps)));
            // Epley formula
            const epley1RM = weight * (1 + (reps / 30));
            // Lander formula
            const lander1RM = (100 * weight) / (101.3 - 2.67123 * reps);
            // Lombardi formula
            const lombardi1RM = weight * Math.pow(reps, 0.10);

            // Average of commonly used formulas
            const validFormulas = [brzycki1RM, mayhew1RM, epley1RM, lander1RM, lombardi1RM].filter(val => !isNaN(val) && val > 0);

            if (validFormulas.length === 0) return 0;
            return validFormulas.reduce((sum, val) => sum + val, 0) / validFormulas.length;
        }

        /**
         * Animates a numerical change from a start value to an end value in a DOM element.
         * @param {HTMLElement} element The DOM element whose text content will be animated.
         * @param {number} startValue The starting numerical value.
         * @param {number} endValue The target numerical value.
         * @param {number} duration The duration of the animation in milliseconds.
         * @param {string} suffix Optional suffix to append (e.g., ' kg', '%').
         */
        function animateNumberChange(element, startValue, endValue, duration, suffix = '') {
            const range = endValue - startValue;
            const startTime = performance.now();

            function update() {
                const elapsed = performance.now() - startTime;
                const progress = Math.min(elapsed / duration, 1); // Clamp between 0 and 1
                const currentValue = startValue + range * progress;
                element.textContent = `${currentValue.toFixed(0)}${suffix}`;

                if (progress < 1) {
                    requestAnimationFrame(update);
                } else {
                    element.textContent = `${endValue.toFixed(0)}${suffix}`; // Ensure final value is exact
                }
            }
            requestAnimationFrame(update);
        }

        function updateAllTotals() {
            let totalTonnage = 0;
            let completedSeriesOverall = 0;
            const exercises = state.sessions[state.currentSessionIndex]?.exercises || [];
            let totalPossibleSeries = exercises.length * 5;
            
            exercises.forEach((ex, idx) => {
                let exerciseTonnage = 0;
                let oneRMs = []; // Array to store 1RM values for each valid series
                let validSeriesCount = 0; // Count of valid series for weighting

                for (let i = 0; i < 5; i++) {
                    const repsInput = document.querySelector(`[data-ex='${idx}'][data-serie='${i}'].reps`);
                    const weightInput = document.querySelector(`[data-ex='${idx}'][data-serie='${i}'].weight`);
                    
                    const repsValue = repsInput?.value.trim() || '';
                    const weightValue = weightInput?.value.trim() || '';

                    const repsSegments = repsValue.split('+').map(s => parseFloat(s.trim().replace(',', '.'))).filter(val => !isNaN(val) && val >= 0);
                    const weightSegments = weightValue.split('+').map(s => parseFloat(s.trim().replace(',', '.'))).filter(val => !isNaN(val) && val >= 0);

                    let currentSeriesTonnage = 0;
                    let currentSeriesValid = false;

                    const minLength = Math.min(repsSegments.length, weightSegments.length);
                    for (let k = 0; k < minLength; k++) {
                        const reps = repsSegments[k];
                        const weight = weightSegments[k];
                        
                        currentSeriesTonnage += reps * weight;
                        if (reps > 0 && weight > 0) {
                            oneRMs.push(calculate1RM(weight, reps));
                            currentSeriesValid = true;
                        }
                    }

                    // Apply inline validation for each series input
                    if (weightInput) {
                        if (!isValidAndCompleteNumber(weightInput.value) && weightInput.value.trim() !== '') {
                             weightInput.classList.add('is-invalid');
                        } else {
                            weightInput.classList.remove('is-invalid');
                        }
                    }
                    if (repsInput) {
                         if (!isValidAndCompleteNumber(repsInput.value) && repsInput.value.trim() !== '') {
                            repsInput.classList.add('is-invalid');
                        } else {
                            repsInput.classList.remove('is-invalid');
                        }
                    }


                    if (currentSeriesValid) {
                        repsInput.classList.add('completed');
                        weightInput.classList.add('completed');
                        completedSeriesOverall++;
                    } else {
                        repsInput?.classList.remove('completed');
                        weightInput?.classList.remove('completed');
                    }
                    
                    exerciseTonnage += currentSeriesTonnage;
                }

                // Calculate weighted average 1RM for the exercise
                let weightedAverage1RM = 0;
                if (oneRMs.length > 0) {
                    let totalWeighted1RM = 0;
                    let totalWeightSum = 0;
                    // Apply inverse weighting based on recency: most recent series has the highest weight.
                    // The last element (most recent) gets full weight, older ones get reduced weight.
                    for (let j = 0; j < oneRMs.length; j++) {
                        const positionFromEnd = oneRMs.length - 1 - j; // 0 for last, 1 for second last, etc.
                        const weightFactor = 1 / (1 + positionFromEnd * 0.2); // Adjust 0.2 for decay rate
                        totalWeighted1RM += oneRMs[j] * weightFactor;
                        totalWeightSum += weightFactor;
                    }
                    weightedAverage1RM = totalWeighted1RM / totalWeightSum;
                }

                const tonnageEl = document.getElementById(`tonnage-${idx}`);
                if(tonnageEl) {
                    tonnageEl.textContent = exerciseTonnage.toFixed(0);
                    tonnageEl.classList.toggle('tonnage-high', exerciseTonnage > 0);
                }
                const oneRmEl = document.getElementById(`onerm-${idx}`);
                if (oneRmEl) {
                    oneRmEl.textContent = weightedAverage1RM > 0 ? weightedAverage1RM.toFixed(1) : '0';
                    oneRmEl.classList.toggle('onerm-high', weightedAverage1RM > 0);
                }
                totalTonnage += exerciseTonnage;
            });

            // Animate total tonnage and delta
            const currentTonnage = parseFloat(dom.totalTonnageEl.textContent.replace(' kg', '')) || 0;
            const newTonnage = totalTonnage;
            animateNumberChange(dom.totalTonnageEl, currentTonnage, newTonnage, 500, ' kg');

            dom.progressBar.setAttribute('aria-valuenow', (totalPossibleSeries > 0 ? (completedSeriesOverall / totalPossibleSeries) * 100 : 0).toFixed(0));

            const previous = parseFloat(dom.previousWeekInput.value) || 0;
            const delta = newTonnage - previous;
            const currentDelta = parseFloat(dom.deltaEl.textContent.replace(' kg', '').replace('+', '')) || 0;
            
            // For delta, animate the absolute value then apply sign and color
            const animateDelta = (targetDelta) => {
                const deltaEl = dom.deltaEl;
                const startDelta = parseFloat(deltaEl.textContent.replace(' kg', '').replace('+', '')) || 0;
                const deltaDuration = 500;
                const deltaStartTime = performance.now();

                function updateDelta() {
                    const elapsed = performance.now() - deltaStartTime;
                    const progress = Math.min(elapsed / deltaDuration, 1);
                    const currentValue = startDelta + (targetDelta - startDelta) * progress;
                    const displayValue = Math.round(currentValue); // Round to integer for display

                    const displaySign = displayValue > 0 ? '+' : '';
                    deltaEl.textContent = `${displaySign}${displayValue} kg`;
                    deltaEl.style.color = displayValue > 0 ? 'var(--success-color)' : displayValue < 0 ? 'var(--danger-color)' : 'inherit';

                    if (progress < 1) {
                        requestAnimationFrame(updateDelta);
                    } else {
                         deltaEl.textContent = `${delta > 0 ? '+' : ''}${delta.toFixed(0)} kg`;
                         deltaEl.style.color = delta > 0 ? 'var(--success-color)' : delta < 0 ? 'var(--danger-color)' : 'inherit';
                    }
                }
                requestAnimationFrame(updateDelta);
            }
            animateDelta(delta); // Call with the final delta value

            dom.progressFill.style.width = `${totalPossibleSeries > 0 ? (completedSeriesOverall / totalPossibleSeries) * 100 : 0}%`;
            saveCurrentState();
        }

        function saveCurrentState() {
            const currentSession = state.sessions[state.currentSessionIndex];
            if (!currentSession) return;
            currentSession.exercises.forEach((ex, idx) => {
                ex.series = Array.from({length: 5}, (_, i) => {
                    const weightInput = document.querySelector(`[data-ex='${idx}'][data-serie='${i}'].weight`);
                    const repsInput = document.querySelector(`[data-ex='${idx}'][data-serie='${i}'].reps`);
                    return {
                        weight: weightInput?.value || '',
                        reps: repsInput?.value || ''
                    };
                });
            });
            // Save calculator input values
            const calculatorState = {
                targetWeight: dom.targetWeightInput.value,
                barbellWeight: dom.barbellWeightInput.value,
                oneRm: dom.oneRmInput.value
            };
            localStorage.setItem('calculatorState', JSON.stringify(calculatorState));

            const data = {
                previousWeek: dom.previousWeekInput.value,
                sessionIndex: state.currentSessionIndex,
                customSessions: state.sessions,
                workoutStartTime: state.workoutStartTime,
                isWorkoutTimerPaused: state.isWorkoutTimerPaused,
                // Ensure pausedTime is updated correctly before saving
                pausedTime: state.isWorkoutTimerPaused ? state.pausedTime : (state.workoutStartTime ? (Date.now() - new Date(state.workoutStartTime).getTime()) / 1000 : 0),
                saveTimestamp: Date.now(),
                sessionNotes: dom.sessionNotesInput.value
            };
            localStorage.setItem('inProgressWorkout', JSON.stringify(data));
        }

        function loadCurrentState() {
            const data = JSON.parse(localStorage.getItem('inProgressWorkout'));
            if (!data) return;
            const currentExercises = state.sessions[state.currentSessionIndex]?.exercises || [];
            currentExercises.forEach((ex, idx) => {
                const repsInputs = document.querySelectorAll(`[data-ex='${idx}'].reps`);
                const weightInputs = document.querySelectorAll(`[data-ex='${idx}'].weight`);
                if (ex.series) {
                    ex.series.forEach((s, i) => {
                        if (repsInputs[i]) repsInputs[i].value = s.reps || '';
                        if (weightInputs[i]) weightInputs[i].value = s.weight || '';
                    });
                }
            });
            dom.previousWeekInput.value = data.previousWeek || "";
            dom.sessionNotesInput.value = data.sessionNotes || "";

            // Load calculator input values
            const calculatorState = JSON.parse(localStorage.getItem('calculatorState'));
            if (calculatorState) {
                dom.targetWeightInput.value = calculatorState.targetWeight || '';
                dom.barbellWeightInput.value = calculatorState.barbellWeight || '';
                dom.oneRmInput.value = calculatorState.oneRm || '';
                // Recalculate results if values are loaded
                calculatePlates();
                calculateTrainingGoals();
            }
        }

        function customConfirm(message) {
            return new Promise(resolve => {
                const modal = document.createElement('div');
                modal.className = 'modal-overlay';
                modal.setAttribute('role', 'dialog');
                modal.setAttribute('aria-modal', 'true');
                modal.setAttribute('aria-labelledby', 'confirmModalTitle');
                modal.innerHTML = `
                    <div class="modal-content" style="text-align: center;">
                        <h2 id="confirmModalTitle" style="font-size: 1.5rem; margin-bottom: var(--spacing-md);">Confirmation</h2>
                        <p style="margin-bottom: var(--spacing-lg);">${message}</p>
                        <div style="display: flex; justify-content: center; gap: var(--spacing-md);">
                            <button class="btn btn-outline confirm-no"><i class="fas fa-times" aria-hidden="true"></i> Non</button>
                            <button class="btn btn-success confirm-yes"><i class="fas fa-check" aria-hidden="true"></i> Oui</button>
                        </div>
                    </div>
                `;
                document.body.appendChild(modal);

                const confirmYesBtn = modal.querySelector('.confirm-yes');
                const confirmNoBtn = modal.querySelector('.confirm-no');
                // Store the element that triggered the modal for focus restoration
                const triggeringElement = document.activeElement;

                const cleanup = () => {
                    modal.classList.remove('show');
                    const fallbackTimeout = setTimeout(() => {
                        if (document.body.contains(modal)) {
                            modal.remove();
                            if (triggeringElement && typeof triggeringElement.focus === 'function') {
                                triggeringElement.focus();
                            }
                        }
                    }, 500); // Give time for transition
                    modal.addEventListener('transitionend', () => {
                        clearTimeout(fallbackTimeout);
                        if (document.body.contains(modal)) {
                           modal.remove();
                           if (triggeringElement && typeof triggeringElement.focus === 'function') {
                                triggeringElement.focus();
                            }
                        }
                    }, { once : true });
                };

                confirmYesBtn.onclick = () => { 
                    cleanup();
                    resolve(true); 
                };

                confirmNoBtn.onclick = () => { 
                    cleanup();
                    resolve(false); 
                };
                
                // Add 'show' class to trigger modal animation
                setTimeout(() => {
                    modal.classList.add('show');
                    // Focus the first interactive element for accessibility
                    confirmNoBtn.focus(); // Focus "No" by default for destructive actions, or "Yes" if less destructive
                }, 10);
            });
        }
        
        function autoSaveSession() {
            if (!state.workoutStartTime || state.isWorkoutTimerPaused) {
                return;
            }
            console.log("Sauvegarde automatique de la session...");
            const workoutData = {
                id: state.workoutStartTime, 
                date: new Date().toISOString(),
                sessionName: dom.sessionSelect.selectedOptions[0].text,
                totalTonnage: +dom.totalTonnageEl.textContent.replace(' kg', ''),
                duration: dom.totalTimeEl.textContent,
                notes: dom.sessionNotesInput.value,
                isAutoSave: true,
                exercises: (state.sessions[state.currentSessionIndex]?.exercises || []).flatMap((ex, idx) => {
                    const exerciseSeries = [];
                    for (let i = 0; i < 5; i++) {
                        const repsInput = document.querySelector(`[data-ex='${idx}'][data-serie='${i}'].reps`);
                        const weightInput = document.querySelector(`[data-ex='${idx}'][data-serie='${i}'].weight`);
                        const repsValues = repsInput?.value.split('+').map(val => parseFloat(val.trim().replace(',', '.'))).filter(val => !isNaN(val) && val >= 0) || [];
                        const weightValues = weightInput?.value.split('+').map(val => parseFloat(val.trim().replace(',', '.'))).filter(val => !isNaN(val) && val >= 0) || [];
                        
                        const minLength = Math.min(repsValues.length, weightValues.length);
                        if (minLength > 0) { // Only add if there's at least one valid pair
                            for (let k = 0; k < minLength; k++) {
                                exerciseSeries.push({ reps: repsValues[k], weight: weightValues[k] });
                            }
                        } else if (repsValues.length > 0 || weightValues.length > 0) {
                            // Handle cases where only reps or only weight is provided
                            if (repsValues.length > 0) {
                                repsValues.forEach(r => exerciseSeries.push({ reps: r, weight: 0 })); // Assume 0 weight if not provided
                            } else if (weightValues.length > 0) {
                                weightValues.forEach(w => exerciseSeries.push({ reps: 0, weight: w })); // Assume 0 reps if not provided
                            }
                        }
                    }
                    if (exerciseSeries.length > 0) {
                        return [{
                            name: ex.name,
                            rest: ex.rest || "1 min",
                            series: exerciseSeries.filter(s => s.reps > 0 || s.weight > 0) // Only save valid series
                        }];
                    }
                    return [];
                })
            };
            let history = getHistory();
            history = history.filter(session => !(session.isAutoSave && session.id === state.workoutStartTime));
            history.push(workoutData);
            localStorage.setItem('workoutHistory', JSON.stringify(history));
            showNotification("Progression de la sÃ©ance sauvegardÃ©e automatiquement.", "info", 3000);
        }
        
        function finishAndSaveSession() {
            const totalTonnage = +dom.totalTonnageEl.textContent.replace(' kg', '');
            if (totalTonnage === 0) {
                showNotification("Aucune donnÃ©e Ã  sauvegarder. La sÃ©ance n'a pas Ã©tÃ© enregistrÃ©e car le tonnage total est de 0 kg.", "info");
                return; 
            }
            pauseTotalWorkoutTimer(); 

            const workoutData = {
                id: Date.now(),
                date: new Date().toISOString(),
                sessionName: dom.sessionSelect.selectedOptions[0].text,
                totalTonnage,
                duration: dom.totalTimeEl.textContent,
                notes: dom.sessionNotesInput.value,
                exercises: (state.sessions[state.currentSessionIndex]?.exercises || []).flatMap((ex, idx) => {
                    const exerciseSeries = [];
                    for (let i = 0; i < 5; i++) {
                        const repsInput = document.querySelector(`[data-ex='${idx}'][data-serie='${i}'].reps`);
                        const weightInput = document.querySelector(`[data-ex='${idx}'][data-serie='${i}'].weight`);
                        const repsValues = repsInput?.value.split('+').map(val => parseFloat(val.trim().replace(',', '.'))).filter(val => !isNaN(val) && val >= 0) || [];
                        const weightValues = weightInput?.value.split('+').map(val => parseFloat(val.trim().replace(',', '.'))).filter(val => !isNaN(val) && val >= 0) || [];
                        
                        const minLength = Math.min(repsValues.length, weightValues.length);
                        if (minLength > 0) {
                            for (let k = 0; k < minLength; k++) {
                                exerciseSeries.push({ reps: repsValues[k], weight: weightValues[k] });
                            }
                        } else if (repsValues.length > 0 || weightValues.length > 0) {
                            if (repsValues.length > 0) {
                                repsValues.forEach(r => exerciseSeries.push({ reps: r, weight: 0 }));
                            } else if (weightValues.length > 0) {
                                weightValues.forEach(w => exerciseSeries.push({ reps: 0, weight: w }));
                            }
                        }
                    }
                    if (exerciseSeries.length > 0) {
                        return [{
                            name: ex.name,
                            rest: ex.rest || "1 min",
                            series: exerciseSeries.filter(s => s.reps > 0 || s.weight > 0)
                        }];
                    }
                    return [];
                })
            };
            let history = getHistory();
            history = history.filter(session => !(session.isAutoSave && session.id === state.workoutStartTime));
            history.push(workoutData);
            localStorage.setItem('workoutHistory', JSON.stringify(history));
            showNotification("SÃ©ance sauvegardÃ©e dans l'historique avec succÃ¨s !", "success");
            
            Object.values(state.timers).forEach(timer => {
                if (timer && timer.interval) clearInterval(timer.interval);
            });
            state.timers = {};
            state.workoutStartTime = null;
            state.isWorkoutTimerPaused = false;
            state.pausedTime = 0;
            dom.timerPlayPauseIcon.textContent = 'â¶ï¸';
            dom.timerPlayPauseText.textContent = 'Play';
            localStorage.removeItem('inProgressWorkout');
            createTable();
            dom.totalTimeEl.textContent = "00:00:00";
            dom.totalTonnageEl.textContent = "0 kg";
            dom.deltaEl.textContent = "0 kg";
            dom.previousWeekInput.value = "";
            dom.sessionNotesInput.value = "";
        }

        function getHistory() { return JSON.parse(localStorage.getItem('workoutHistory')) || []; }
        
        function displayHistory() {
            dom.historyList.innerHTML = '';
            const sortedHistory = getHistory().sort((a, b) => new Date(b.date) - new Date(a.date));

            if (sortedHistory.length === 0) {
                dom.historyList.innerHTML = '<p style="text-align: center; color: var(--sub-header-color);">Aucune sÃ©ance enregistrÃ©e dans l\'historique.</p>';
                return;
            }

            sortedHistory.forEach(session => {
                const item = document.createElement('div');
                item.className = 'history-item';
                item.setAttribute('role', 'listitem');
                item.innerHTML = `
                    <div>
                        ${new Date(session.date).toLocaleDateString('fr-FR')} - 
                        <strong>${session.sessionName}</strong> (${session.totalTonnage} kg)
                        ${session.duration ? ` - â±ï¸ ${session.duration}` : ''}
                    </div>
                    <div style="display: flex; gap: var(--spacing-xs);">
                        <button class="btn btn-ghost" data-history-action="details" data-history-id="${session.id}" title="Voir les dÃ©tails de ${session.sessionName}"><i class="fas fa-info-circle" aria-hidden="true"></i></button>
                        <button class="btn btn-ghost" data-history-action="load" data-history-id="${session.id}" title="Utiliser cette sÃ©ance comme modÃ¨le"><i class="fas fa-arrow-alt-circle-down" aria-hidden="true"></i></button>
                        <button class="btn-ghost" data-history-action="delete" data-history-id="${session.id}" title="Supprimer ${session.sessionName} de l'historique"><i class="fas fa-trash-alt" aria-hidden="true"></i></button>
                    </div>
                    <div class="history-details" id="details-${session.id}" role="region" aria-live="polite"></div>`;
                dom.historyList.appendChild(item);
            });
        }
        
        function showHistoryDetails(id) {
            const detailsDiv = document.getElementById(`details-${id}`);
            const button = detailsDiv.previousElementSibling.querySelector('[data-history-action="details"]');
            
            if (detailsDiv.classList.contains('visible')) {
                detailsDiv.classList.remove('visible');
                detailsDiv.innerHTML = '';
                button.setAttribute('aria-expanded', 'false');
            } else {
                const session = getHistory().find(s => s.id == id);
                if (session) {
                    let detailsHtml = `<h4>DÃ©tails de la SÃ©ance :</h4>
                                       <p><strong>Tonnage Total :</strong> ${session.totalTonnage} kg</p>`;
                    if (session.notes) {
                        detailsHtml += `<p><strong>Notes :</strong> ${session.notes}</p>`;
                    }
                    detailsHtml += `<ul>`;
                    session.exercises.forEach(ex => {
                        let exerciseOneRMs = []; // Store 1RMs for all valid series in this exercise
                        if (ex.series && ex.series.length > 0) {
                            ex.series.forEach(s => {
                                const repsValues = String(s.reps).split('+').map(val => parseFloat(val.trim().replace(',', '.'))).filter(val => !isNaN(val) && val > 0);
                                const weightValues = String(s.weight).split('+').map(val => parseFloat(val.trim().replace(',', '.'))).filter(val => !isNaN(val) && val > 0);
                                
                                const minLength = Math.min(repsValues.length, weightValues.length);
                                for (let k = 0; k < minLength; k++) {
                                    const reps = repsValues[k];
                                    const weight = weightValues[k];
                                    if (reps > 0 && weight > 0) {
                                        exerciseOneRMs.push(calculate1RM(weight, reps));
                                    }
                                }
                            });
                        }
                        let weightedAverage1RM = 0;
                        if (exerciseOneRMs.length > 0) {
                            let totalWeighted1RM = 0;
                            let totalWeightSum = 0;
                            for (let j = 0; j < exerciseOneRMs.length; j++) {
                                const positionFromEnd = exerciseOneRMs.length - 1 - j;
                                const weightFactor = 1 / (1 + positionFromEnd * 0.2);
                                totalWeighted1RM += exerciseOneRMs[j] * weightFactor;
                                totalWeightSum += weightFactor;
                            }
                            weightedAverage1RM = totalWeighted1RM / totalWeightSum;
                        }
                        detailsHtml += `<li><strong>${ex.name}</strong> - 1RM Moy: ${weightedAverage1RM.toFixed(1)} kg</li>`;
                    });
                    detailsHtml += '</ul>';
                    detailsDiv.innerHTML = detailsHtml;
                    detailsDiv.classList.add('visible');
                    button.setAttribute('aria-expanded', 'true');
                }
            } 
        }
        
        // ================== NEW ADVANCED CSV EXPORT/IMPORT LOGIC ==================
        /**
         * Safely escapes a string for CSV format by doubling quotes and wrapping in quotes if necessary.
         * @param {string} str - The string to escape.
         * @returns {string} The escaped string.
         */
        const escapeCsv = (str) => {
            const s = String(str || '');
            if (s.includes(';') || s.includes('"') || s.includes('\n')) {
                return `"${s.replace(/"/g, '""')}"`;
            }
            return s;
        };

        /**
         * Exports the session history to an advanced CSV format.
         * Each session has a main row, and exercises/series are indented on subsequent rows.
         */
        function exportCSV() {
            const history = getHistory();
            if (history.length === 0) {
                showNotification("Aucune donnÃ©e historique Ã  exporter. L'exportation CSV est vide.", "info");
                return;
            }

            // Define headers for the advanced format
            const headers = [
                "Type", // 'Session', 'Exercice', or 'Serie'
                "Date/ID",
                "Nom",
                "Duree",
                "Serie",
                "Reps",
                "Poids",
                "Notes"
            ];
            let csvContent = headers.join(';') + '\n';

            history.forEach((session, index) => {
                // Main session row
                const sessionDate = new Date(session.date).toLocaleString('fr-FR', {
                    year: 'numeric', month: '2-digit', day: '2-digit',
                    hour: '2-digit', minute: '2-digit'
                });
                const sessionRow = [
                    "Session",
                    escapeCsv(sessionDate),
                    escapeCsv(session.sessionName),
                    escapeCsv(session.duration),
                    '', '', '', // Empty cells for series data
                    escapeCsv(session.notes)
                ];
                csvContent += sessionRow.join(';') + '\n';

                // Exercise and series rows
                session.exercises.forEach(ex => {
                    const exerciseRow = [
                        "Exercice",
                        '', // No date for exercise row
                        escapeCsv(ex.name),
                        '', '', '', '', '' // Empty cells
                    ];
                    csvContent += exerciseRow.join(';') + '\n';

                    if (ex.series && ex.series.length > 0) {
                        ex.series.forEach((serie, i) => {
                            const serieRow = [
                                "Serie",
                                '', '', '', // Empty cells for session/exercise info
                                `SÃ©rie ${i + 1}`,
                                escapeCsv(String(serie.reps).replace('.', ',')),
                                escapeCsv(String(serie.weight).replace('.', ',')),
                                '' // No notes for individual series
                            ];
                            csvContent += serieRow.join(';') + '\n';
                        });
                    }
                });

                // Add a separator line between sessions for readability, unless it's the last one
                if (index < history.length - 1) {
                    csvContent += '---;---;---;---;---;---;---;---\n';
                }
            });

            const blob = new Blob([new Uint8Array([0xEF, 0xBB, 0xBF]), csvContent], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement("a");
            link.href = URL.createObjectURL(blob);
            link.download = `historique_seances_avance_${new Date().toISOString().split('T')[0]}.csv`;
            link.click();
            URL.revokeObjectURL(link.href);
            showNotification("Exportation de l'historique CSV (format avancÃ©) rÃ©ussie !", "success");
        }

        /**
         * Parses CSV content from either the old simple format or the new advanced format.
         * @param {string} csvContent - The raw content from the CSV file.
         * @returns {Array} An array of session objects.
         */
        function parseCsvToHistory(csvContent) {
            const lines = csvContent.replace(/\r/g, '').split('\n').filter(line => line.trim() !== '' && !line.startsWith('---'));
            if (lines.length <= 1) return [];

            const firstLine = lines[0].split(';').map(h => h.trim());
            
            // Check if it's the new advanced format by looking for a 'Type' header
            if (firstLine[0].toLowerCase() === 'type') {
                return parseAdvancedCsv(lines);
            } else {
                // Fallback to the original simple parser
                return parseSimpleCsv(lines);
            }
        }

        /**
         * Parses the new advanced CSV format.
         * @param {Array<string>} lines - The lines from the CSV file.
         * @returns {Array} An array of session objects.
         */
        function parseAdvancedCsv(lines) {
            const headers = lines[0].split(';').map(h => h.trim());
            const history = [];
            let currentSession = null;
            let currentExercise = null;

            for (let i = 1; i < lines.length; i++) {
                const values = lines[i].split(';');
                const row = Object.fromEntries(headers.map((header, index) => [header, values[index]?.trim().replace(/^"|"$/g, '').replace(/""/g, '"') || '']));
                
                const type = row['Type']?.toLowerCase();

                if (type === 'session') {
                    const dateString = row['Date/ID'];
                    const dateParts = dateString.match(/(\d{2})\/(\d{2})\/(\d{4})[,\s]*(\d{2}):(\d{2})/);
                    let parsedDate = dateParts ? new Date(`${dateParts[3]}-${dateParts[2]}-${dateParts[1]}T${dateParts[4]}:${dateParts[5]}:00`) : new Date(dateString);
                    if (isNaN(parsedDate.getTime())) continue;

                    currentSession = {
                        id: parsedDate.getTime(),
                        date: parsedDate.toISOString(),
                        sessionName: row['Nom'],
                        duration: row['Duree'] || '00:00:00',
                        notes: row['Notes'] || '',
                        exercises: []
                    };
                    history.push(currentSession);
                    currentExercise = null; // Reset current exercise
                } else if (type === 'exercice' && currentSession) {
                    currentExercise = {
                        name: row['Nom'],
                        rest: '1 min', // Default rest time
                        series: []
                    };
                    currentSession.exercises.push(currentExercise);
                } else if (type === 'serie' && currentExercise) {
                    const reps = row['Reps']?.replace(',', '.') || '0';
                    const weight = row['Poids']?.replace(',', '.') || '0';
                    if (parseFloat(reps) > 0 || parseFloat(weight) > 0) {
                        currentExercise.series.push({ reps, weight });
                    }
                }
            }

            // Recalculate tonnage for each session
            history.forEach(session => {
                let sessionTonnage = 0;
                session.exercises.forEach(ex => {
                    ex.series.forEach(serie => {
                        const repsValue = String(serie.reps).split('+').reduce((sum, val) => sum + (parseFloat(val) || 0), 0);
                        const weightValue = String(serie.weight).split('+').reduce((sum, val) => sum + (parseFloat(val) || 0), 0);
                        sessionTonnage += repsValue * weightValue;
                    });
                });
                session.totalTonnage = parseFloat(sessionTonnage.toFixed(0));
            });

            return history;
        }

        /**
         * Parses the original simple CSV format (one line per series).
         * @param {Array<string>} lines - The lines from the CSV file.
         * @returns {Array} An array of session objects.
         */
        function parseSimpleCsv(lines) {
            const headers = lines[0].split(';').map(h => h.trim());
            const sessionsMap = new Map();

            for (let i = 1; i < lines.length; i++) {
                const values = lines[i].split(';');
                if (values.length < headers.length) continue;
                const row = Object.fromEntries(headers.map((header, index) => [header, values[index]?.trim().replace(/^"|"$/g, '').replace(/""/g, '"') || '']));
                
                const dateString = row['DateSession'];
                if (!dateString) continue;

                const dateParts = dateString.match(/(\d{2})\/(\d{2})\/(\d{4})[,\s]*(\d{2}):(\d{2})/);
                let parsedDate = dateParts ? new Date(`${dateParts[3]}-${dateParts[2]}-${dateParts[1]}T${dateParts[4]}:${dateParts[5]}:00`) : new Date(dateString);
                if (isNaN(parsedDate.getTime())) continue;

                let sessionId = parsedDate.getTime() + '_' + row['NomSeance'];
                if (!sessionsMap.has(sessionId)) {
                    sessionsMap.set(sessionId, {
                        id: parsedDate.getTime(),
                        date: parsedDate.toISOString(),
                        sessionName: row['NomSeance'],
                        totalTonnage: 0,
                        duration: row['DureeTotaleSeance'] || '00:00:00',
                        notes: row['Notes'] || '',
                        exercises: []
                    });
                }
                
                const currentSession = sessionsMap.get(sessionId);
                const exerciseName = row['Exercice'];
                if (exerciseName) {
                    let currentExercise = currentSession.exercises.find(ex => ex.name === exerciseName);
                    if (!currentExercise) {
                        currentExercise = { name: exerciseName, rest: '1 min', series: [] };
                        currentSession.exercises.push(currentExercise);
                    }
                    const reps = row['Reps']?.replace(',', '.') || '0';
                    const weight = row['Poids']?.replace(',', '.') || '0';
                    if (parseFloat(reps) > 0 || parseFloat(weight) > 0) {
                        currentExercise.series.push({ reps, weight });
                    }
                }
            }
            const finalHistory = Array.from(sessionsMap.values());
            finalHistory.forEach(session => {
                let sessionTonnage = 0;
                session.exercises.forEach(ex => {
                    ex.series.forEach(serie => {
                        const repsValue = String(serie.reps).split('+').reduce((sum, val) => sum + (parseFloat(val) || 0), 0);
                        const weightValue = String(serie.weight).split('+').reduce((sum, val) => sum + (parseFloat(val) || 0), 0);
                        sessionTonnage += repsValue * weightValue;
                    });
                });
                session.totalTonnage = parseFloat(sessionTonnage.toFixed(0));
            });
            
            return finalHistory;
        }

        // =============================================================
        
        function showNotification(message, type = 'info', duration = 5000) { 
            const notification = document.createElement('div');
            notification.className = `notification ${type}`;
            notification.innerHTML = `<span>${message}</span>`;
            dom.notificationContainer.appendChild(notification);
            void notification.offsetWidth;
            notification.classList.add('show');
            setTimeout(() => {
                notification.classList.remove('show');
                notification.addEventListener('transitionend', () => notification.remove(), { once : true });
            }, duration);
        }

        function showUndoableNotification(message, onUndoCallback, duration = 7000) {
            const notification = document.createElement('div');
            notification.className = `notification info`; 
            notification.innerHTML = `
                <span>${message}</span>
                <button class="btn btn-secondary" id="undoBtn" style="margin-left: 1rem; padding: 0.5rem 1rem; border-radius: 15px;">Annuler</button>
            `;
            dom.notificationContainer.appendChild(notification);
            void notification.offsetWidth; 
            notification.classList.add('show');
            let timer; 
            const closeNotification = () => {
                notification.classList.remove('show');
                notification.addEventListener('transitionend', () => notification.remove(), { once : true });
            };
            const undoButton = notification.querySelector('#undoBtn');
            if (undoButton) {
                undoButton.addEventListener('click', () => {
                    clearTimeout(timer); 
                    onUndoCallback(); 
                    closeNotification(); 
                });
            }
            timer = setTimeout(closeNotification, duration);
        }

        function formatTime(seconds) {
            const h = Math.floor(seconds / 3600);
            const m = Math.floor((seconds % 3600) / 60);
            const s = Math.floor(seconds % 60);
            return `${String(h).padStart(2,'0')}:${String(m).padStart(2,'0')}:${String(s).padStart(2,'0')}`;
        }
        
        function formatTimerDisplay(seconds) {
             const m = Math.floor(seconds / 60);
             const s = Math.floor(seconds % 60);
             return `${m}:${String(s).padStart(2, '0')}`;
        }

        function updateTotalTimeDisplay() {
            if (!state.workoutStartTime) {
                dom.totalTimeEl.textContent = "00:00:00";
                return;
            }
            const elapsedSeconds = state.isWorkoutTimerPaused ? state.pausedTime : (Date.now() - new Date(state.workoutStartTime).getTime()) / 1000;
            dom.totalTimeEl.textContent = formatTime(elapsedSeconds);
        }
        
        function resetInactivityTimer() {
            clearTimeout(state.inactivityTimeout);
            if (state.workoutStartTime && !state.isWorkoutTimerPaused) {
                state.inactivityTimeout = setTimeout(() => {
                    pauseTotalWorkoutTimer();
                    showNotification("Minuteur mis en pause pour inactivitÃ©.", "info");
                }, 600000); // 10 minutes
            }
        }

        function startInactivityAndAutoSaveTimers() {
            resetInactivityTimer();
            if (state.autoSaveInterval) clearInterval(state.autoSaveInterval);
            state.autoSaveInterval = setInterval(autoSaveSession, 2400000); // 40 minutes
            document.addEventListener('mousemove', resetInactivityTimer);
            document.addEventListener('keydown', resetInactivityTimer);
            document.addEventListener('click', resetInactivityTimer);
            // Add listeners for visibility changes
            document.addEventListener('visibilitychange', handleVisibilityChange);
        }

        function stopInactivityAndAutoSaveTimers() {
            clearTimeout(state.inactivityTimeout);
            clearInterval(state.autoSaveInterval);
            state.autoSaveInterval = null;
            document.removeEventListener('mousemove', resetInactivityTimer);
            document.removeEventListener('keydown', resetInactivityTimer);
            document.removeEventListener('click', resetInactivityTimer);
            document.removeEventListener('visibilitychange', handleVisibilityChange);
        }

        function startTotalWorkoutTimer() {
            if (state.totalWorkoutTimeInterval) clearInterval(state.totalWorkoutTimeInterval);

            if (!state.workoutStartTime) {
                 state.workoutStartTime = new Date().toISOString();
                 state.pausedTime = 0; 
            } else if (state.isWorkoutTimerPaused) {
                // When resuming from a paused state, adjust the workoutStartTime
                // so that the current pausedTime is correctly factored in.
                state.workoutStartTime = new Date(Date.now() - state.pausedTime * 1000).toISOString();
            }
            
            state.isWorkoutTimerPaused = false;
            state.totalWorkoutTimeInterval = setInterval(updateTotalTimeDisplay, 1000);
            startInactivityAndAutoSaveTimers();
            updateTotalTimeDisplay(); 
            dom.timerPlayPauseIcon.textContent = 'â¸ï¸';
            dom.timerPlayPauseText.textContent = 'Pause';
            saveCurrentState(); // Save state after starting timer
        }

        function pauseTotalWorkoutTimer() {
            if (state.totalWorkoutTimeInterval) {
                clearInterval(state.totalWorkoutTimeInterval);
                state.totalWorkoutTimeInterval = null;
            }
            if (state.workoutStartTime) {
                // Calculate total elapsed time up to the point of pausing
                state.pausedTime = (Date.now() - new Date(state.workoutStartTime).getTime()) / 1000;
            }
            state.isWorkoutTimerPaused = true;
            stopInactivityAndAutoSaveTimers();
            dom.timerPlayPauseIcon.textContent = 'â¶ï¸';
            dom.timerPlayPauseText.textContent = 'Play';
            updateTotalTimeDisplay(); 
            saveCurrentState(); // Save state after pausing timer
        }

        function handleVisibilityChange() {
            if (document.hidden) {
                // User is leaving the page
                if (state.workoutStartTime && !state.isWorkoutTimerPaused) {
                    pauseTotalWorkoutTimer();
                    saveCurrentState(); // Ensure state is saved immediately
                }
            } else {
                // User is returning to the page
                const inProgress = JSON.parse(localStorage.getItem('inProgressWorkout'));
                if (inProgress && inProgress.workoutStartTime) { // Check if a workout was in progress
                    state.workoutStartTime = inProgress.workoutStartTime;
                    state.isWorkoutTimerPaused = inProgress.isWorkoutTimerPaused;
                    state.pausedTime = inProgress.pausedTime;

                    if (!state.isWorkoutTimerPaused) {
                        // If it was active, account for time passed while hidden
                        const elapsedWhileHidden = (Date.now() - (inProgress.saveTimestamp || new Date(state.workoutStartTime).getTime())) / 1000;
                        state.pausedTime = (inProgress.pausedTime || 0) + elapsedWhileHidden;
                        startTotalWorkoutTimer();
                    } else {
                        // If it was paused, just update display to last known paused time
                        dom.totalTimeEl.textContent = formatTime(state.pausedTime);
                        dom.timerPlayPauseIcon.textContent = 'â¶ï¸';
                        dom.timerPlayPauseText.textContent = 'Play';
                    }
                }
            }
        }

        function applyTheme(theme) {
            if (theme === 'dark') {
                dom.body.classList.add('dark-mode');
                dom.themeToggleBtn.innerHTML = '<i class="fas fa-sun" aria-hidden="true"></i>';
                dom.themeToggleBtn.setAttribute('title', 'Passer au thÃ¨me clair');
            } else {
                dom.body.classList.remove('dark-mode');
                dom.themeToggleBtn.innerHTML = '<i class="fas fa-moon" aria-hidden="true"></i>';
                dom.themeToggleBtn.setAttribute('title', 'Passer au thÃ¨me sombre');
            }
        }

        function updateSessionSelectOptions() {
            dom.sessionSelect.innerHTML = '';
            state.sessions.forEach((session, index) => {
                const option = document.createElement('option');
                option.value = index;
                option.textContent = session.name; 
                dom.sessionSelect.appendChild(option);
            });
        }

        function showNewSessionModal() {
            dom.newSessionModal.classList.remove('hidden');
            dom.newSessionModal.classList.add('show'); /* Add show class for animation */
            dom.newSessionNameInput.value = ''; 
            dom.newSessionNameInput.focus(); 
            dom.newSessionNameInput.classList.remove('is-invalid'); // Clear previous validation
            dom.newSessionNameError.textContent = '';
        }

        function hideNewSessionModal() {
            dom.newSessionModal.classList.remove('show');
            // Store the element that triggered the modal for focus restoration
            const triggeringElement = document.activeElement;
            dom.newSessionModal.addEventListener('transitionend', () => {
                dom.newSessionModal.classList.add('hidden');
                if (triggeringElement && typeof triggeringElement.focus === 'function') {
                    triggeringElement.focus();
                }
            }, { once: true });
        }

        async function createNewSession() {
            const newName = dom.newSessionNameInput.value.trim();
            if (!newName) {
                dom.newSessionNameInput.classList.add('is-invalid');
                dom.newSessionNameError.textContent = 'Le nom de la sÃ©ance ne peut pas Ãªtre vide.';
                return;
            }
            const isDuplicate = state.sessions.some(s => s.name.toLowerCase() === newName.toLowerCase());
            if (isDuplicate) {
                dom.newSessionNameInput.classList.add('is-invalid');
                dom.newSessionNameError.textContent = `Une sÃ©ance nommÃ©e "${newName}" existe dÃ©jÃ . Veuillez choisir un nom diffÃ©rent.`;
                return;
            }
            dom.newSessionNameInput.classList.remove('is-invalid');
            dom.newSessionNameError.textContent = '';

            const newSession = { name: newName, exercises: [] };
            state.sessions.push(newSession);
            updateSessionSelectOptions(); 
            state.currentSessionIndex = state.sessions.length - 1; 
            dom.sessionSelect.value = state.currentSessionIndex;
            localStorage.removeItem('inProgressWorkout');
            state.workoutStartTime = null;
            state.isWorkoutTimerPaused = false;
            state.pausedTime = 0;
            dom.totalTimeEl.textContent = "00:00:00";
            dom.timerPlayPauseIcon.textContent = 'â¶ï¸';
            dom.timerPlayPauseText.textContent = 'Play';
            createTable(); 
            updateAllTotals(); 
            showNotification(`SÃ©ance "${newName}" crÃ©Ã©e avec succÃ¨s !`, "success");
            hideNewSessionModal();
        }

        function updateDeleteSessionButtonState() {
            const currentSession = state.sessions[state.currentSessionIndex];
            if (currentSession && !defaultSessionNames.includes(currentSession.name)) {
                dom.deleteCurrentSessionBtn.removeAttribute('disabled');
                dom.deleteCurrentSessionBtn.classList.remove('btn-outline'); // Re-enable styling
                dom.deleteCurrentSessionBtn.classList.add('btn-danger'); // Add danger styling
            } else {
                dom.deleteCurrentSessionBtn.setAttribute('disabled', 'true');
                dom.deleteCurrentSessionBtn.classList.remove('btn-danger'); // Remove danger styling
                dom.deleteCurrentSessionBtn.classList.add('btn-outline'); // Grey out
            }
        }

        async function deleteCurrentSession() {
            const currentSession = state.sessions[state.currentSessionIndex];
            if (!currentSession || defaultSessionNames.includes(currentSession.name)) {
                showNotification("Vous ne pouvez pas supprimer une sÃ©ance par dÃ©faut.", "error");
                return;
            }
            const confirmed = await customConfirm(`Ãtes-vous sÃ»r de vouloir supprimer dÃ©finitivement la sÃ©ance "${currentSession.name}"? Cette action est irrÃ©versible.`);
            if (confirmed) {
                state.sessions.splice(state.currentSessionIndex, 1);
                state.currentSessionIndex = 0; // Switch to the first session after deletion
                updateSessionSelectOptions();
                dom.sessionSelect.value = state.currentSessionIndex;
                localStorage.removeItem('inProgressWorkout'); // Clear current workout progress
                state.workoutStartTime = null;
                state.isWorkoutTimerPaused = false;
                state.pausedTime = 0;
                dom.totalTimeEl.textContent = "00:00:00";
                dom.timerPlayPauseIcon.textContent = 'â¶ï¸';
                dom.timerPlayPauseText.textContent = 'Play';
                createTable();
                updateAllTotals();
                showNotification(`SÃ©ance "${currentSession.name}" supprimÃ©e avec succÃ¨s.`, "info");
            }
        }


        async function openNewSessionLogic(historicalSession) {
            const confirmed = await customConfirm("Ouvrir cette sÃ©ance ? La sÃ©ance en cours sera remplacÃ©e et toutes les donnÃ©es non sauvegardÃ©es seront perdues.");
            if (!confirmed) return;
            Object.values(state.timers).forEach(timer => {
                if (timer && timer.interval) clearInterval(timer.interval);
            });
            state.timers = {};
            if (state.totalWorkoutTimeInterval) {
                clearInterval(state.totalWorkoutTimeInterval);
                state.totalWorkoutTimeInterval = null;
            }
            state.workoutStartTime = null;
            state.isWorkoutTimerPaused = false;
            state.pausedTime = 0;
            dom.timerPlayPauseIcon.textContent = 'â¶ï¸';
            dom.timerPlayPauseText.textContent = 'Play';
            localStorage.removeItem('inProgressWorkout');
            dom.totalTimeEl.textContent = "00:00:00";
            dom.totalTonnageEl.textContent = "0 kg";
            dom.deltaEl.textContent = "0 kg";
            dom.previousWeekInput.value = "";
            dom.sessionNotesInput.value = ""; 
            let sessionIndexToLoad = state.sessions.findIndex(s => s.name === historicalSession.sessionName);
            if (sessionIndexToLoad === -1) {
                // If the historical session's name doesn't exist in current templates, create a new one
                const newTemplateExercises = historicalSession.exercises.map(ex => ({
                    name: ex.name,
                    rest: ex.rest || "1 min",
                    series: ex.series || []
                }));
                const newTemplate = { name: historicalSession.sessionName, exercises: newTemplateExercises };
                state.sessions.push(newTemplate);
                sessionIndexToLoad = state.sessions.length - 1;
                updateSessionSelectOptions(); 
            } else {
                // If template exists, just load exercises into it
                state.sessions[sessionIndexToLoad].exercises = historicalSession.exercises.map(ex => ({
                    name: ex.name,
                    rest: ex.rest || "1 min",
                    series: ex.series || []
                }));
            }
            state.currentSessionIndex = sessionIndexToLoad;
            dom.sessionSelect.value = state.currentSessionIndex; 
            createTable();
            dom.previousWeekInput.value = historicalSession.totalTonnage; 
            dom.sessionNotesInput.value = historicalSession.notes || ""; 
            updateAllTotals(); 
            showNotification(`SÃ©ance "${historicalSession.sessionName}" ouverte et chargÃ©e avec succÃ¨s.`, "success", 3000);
            dom.loadOptionsModal.classList.remove('show'); // Trigger fade out
            const triggeringElement = document.activeElement; // Save triggering element for focus restore
            dom.loadOptionsModal.addEventListener('transitionend', () => {
                dom.loadOptionsModal.classList.add('hidden');
                if (triggeringElement && typeof triggeringElement.focus === 'function') {
                    triggeringElement.focus();
                }
            }, { once: true });
            dom.historyModal.classList.remove('show'); // Trigger fade out
            dom.historyModal.addEventListener('transitionend', () => dom.historyModal.classList.add('hidden'), { once: true });
        }

        async function appendToCurrentSessionLogic(historicalSession) {
            const confirmed = await customConfirm("Ajouter/mettre Ã  jour les exercices de cette sÃ©ance Ã  la sÃ©ance en cours ? Cela Ã©crasera les sÃ©ries existantes pour les exercices ayant le mÃªme nom.");
            if (!confirmed) return;
            const currentSession = state.sessions[state.currentSessionIndex];
            if (!currentSession.exercises) {
                currentSession.exercises = []; 
            }
            let exercisesAdded = 0;
            let exercisesUpdated = 0;
            historicalSession.exercises.forEach(historicalEx => {
                const existingExIndex = currentSession.exercises.findIndex(ex => ex.name === historicalEx.name);
                if (existingExIndex !== -1) {
                    const currentEx = currentSession.exercises[existingExIndex];
                    currentEx.series = JSON.parse(JSON.stringify(historicalEx.series));
                    exercisesUpdated++;
                } else {
                    currentSession.exercises.push(JSON.parse(JSON.stringify(historicalEx)));
                    exercisesAdded++;
                }
            });
            createTable(); 
            dom.previousWeekInput.value = historicalSession.totalTonnage; 
            dom.sessionNotesInput.value = historicalSession.notes || ""; 
            showNotification(`${exercisesAdded} exercices ajoutÃ©s et ${exercisesUpdated} mis Ã  jour dans la sÃ©ance en cours.`, "success", 5000);
            dom.loadOptionsModal.classList.remove('show'); // Trigger fade out
            const triggeringElement = document.activeElement; // Save triggering element for focus restore
            dom.loadOptionsModal.addEventListener('transitionend', () => {
                dom.loadOptionsModal.classList.add('hidden');
                if (triggeringElement && typeof triggeringElement.focus === 'function') {
                    triggeringElement.focus();
                }
            }, { once: true });
            dom.historyModal.classList.remove('show'); // Trigger fade out
            dom.historyModal.addEventListener('transitionend', () => dom.historyModal.classList.add('hidden'), { once: true });
        }

        function showLoadOptionsModal(session) {
            state.sessionToLoad = session; 
            dom.loadSessionNameDisplay.textContent = session.sessionName;
            dom.loadOptionsModal.classList.remove('hidden');
            dom.loadOptionsModal.classList.add('show'); /* Add show class for animation */
            const firstButton = dom.loadOptionsModal.querySelector('button');
            if (firstButton) firstButton.focus();
        }

        function hideLoadOptionsModal() {
            dom.loadOptionsModal.classList.remove('show');
            const triggeringElement = document.activeElement; // Save triggering element for focus restore
            dom.loadOptionsModal.addEventListener('transitionend', () => {
                dom.loadOptionsModal.classList.add('hidden');
                state.sessionToLoad = null; 
                if (triggeringElement && typeof triggeringElement.focus === 'function') {
                    triggeringElement.focus();
                }
            }, { once : true });
        }

        function parseExerciseList(rawList) {
            return rawList;
        }

        function showSuggestions(input) {
            const query = input.value.toLowerCase();
            dom.autocompleteSuggestions.innerHTML = '';
            if (query.length < 2) { 
                dom.autocompleteSuggestions.classList.remove('show');
                dom.autocompleteSuggestions.classList.add('hidden');
                return;
            }
            const filteredSuggestions = state.availableExercises.filter(exercise => 
                exercise.toLowerCase().includes(query)
            ).slice(0, 10); 
            if (filteredSuggestions.length > 0) {
                filteredSuggestions.forEach((suggestion, index) => {
                    const div = document.createElement('div');
                    div.textContent = suggestion;
                    div.setAttribute('role', 'option');
                    div.id = `autocomplete-option-${index}`;
                    div.addEventListener('click', () => {
                        input.value = suggestion;
                        dom.autocompleteSuggestions.classList.remove('show');
                        dom.autocompleteSuggestions.addEventListener('transitionend', () => {
                            dom.autocompleteSuggestions.classList.add('hidden');
                            dom.autocompleteSuggestions.innerHTML = ''; 
                        }, { once: true });
                    });
                    dom.autocompleteSuggestions.appendChild(div);
                });
                dom.autocompleteSuggestions.classList.remove('hidden');
                dom.autocompleteSuggestions.classList.add('show');
                // Set aria-activedescendant for accessibility if needed (more complex for full implementation)
            } else {
                dom.autocompleteSuggestions.classList.remove('show');
                dom.autocompleteSuggestions.addEventListener('transitionend', () => {
                    dom.autocompleteSuggestions.classList.add('hidden');
                }, { once : true });
            }
        }

        function hideSuggestionsOnClickOutside(event) {
            if (!dom.autocompleteSuggestions.contains(event.target) && event.target !== dom.customExerciseInput) {
                dom.autocompleteSuggestions.classList.remove('show');
                dom.autocompleteSuggestions.addEventListener('transitionend', () => {
                    dom.autocompleteSuggestions.classList.add('hidden');
                }, { once : true });
            }
        }

        function playBeep() {
            try {
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                oscillator.type = 'sine'; 
                oscillator.frequency.setValueAtTime(500, audioContext.currentTime); 
                gainNode.gain.setValueAtTime(0, audioContext.currentTime);
                gainNode.gain.linearRampToValueAtTime(0.5, audioContext.currentTime + 0.01); 
                gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.5); 
                oscillator.start(audioContext.currentTime);
                oscillator.stop(audioContext.currentTime + 0.5); 
            } catch (error) {
                console.warn("Could not play sound: AudioContext not supported or blocked.", error);
            }
        }

        // Helper to check if an input value is a valid, complete number (not a partial entry like "1." or empty)
        function isValidAndCompleteNumber(value) {
            if (value === null || value.trim() === '') return false;
            // Use a regex to allow integers and decimals with at most two decimal places.
            const regex = /^\d+(\.\d{1,2})?$/;
            return regex.test(value.trim()) && parseFloat(value) >= 0;
        }

        /**
         * Loads and resumes individual exercise timers from localStorage.
         * This function is called on application initialization to maintain timer state
         * across browser sessions or page reloads.
         */
        function loadPersistentIndividualTimers() {
            for (let i = 0; i < localStorage.length; i++) {
                const key = localStorage.key(i);
                if (key.startsWith('timer-')) {
                    const idx = parseInt(key.replace('timer-', ''), 10);
                    try {
                        const storedTimer = JSON.parse(localStorage.getItem(key));
                        // Ensure storedTimer is valid and has not expired
                        if (storedTimer && storedTimer.endTime > Date.now()) {
                            const remainingSeconds = (storedTimer.endTime - Date.now()) / 1000;
                            if (remainingSeconds > 0) {
                                const element = document.querySelector(`[data-exercise-index="${idx}"]`);
                                if (element) {
                                    const timerDisplay = element.querySelector('.timer-display');
                                    const startBtn = element.querySelector('[data-timer-action="start"]');
                                    const stopBtn = element.querySelector('[data-timer-action="stop"]');

                                    // Clear any existing interval for this timer to prevent duplicates
                                    if (state.timers[idx] && state.timers[idx].interval) {
                                        clearInterval(state.timers[idx].interval);
                                    }

                                    // Re-establish the timer state
                                    state.timers[idx] = {
                                        secondsElapsed: storedTimer.duration - remainingSeconds, // Calculate elapsed time
                                        duration: storedTimer.duration,
                                        interval: setInterval(() => {
                                            state.timers[idx].secondsElapsed++;
                                            const currentRemaining = state.timers[idx].duration - state.timers[idx].secondsElapsed;
                                            if (currentRemaining <= 0) {
                                                timerDisplay.textContent = formatTimerDisplay(0); // Show 0:00 when finished
                                                timerDisplay.classList.remove('timer-active');
                                                clearInterval(state.timers[idx].interval);
                                                localStorage.removeItem(`timer-${idx}`); // Clean up storage
                                                playBeep(); 
                                                if(Notification.permission === "granted") {
                                                    new Notification('Lyftiv - Repos TerminÃ© !', { body: `Le temps de repos pour ${storedTimer.name} est terminÃ©.`});
                                                }
                                                // Reset buttons and display original duration after timer finishes
                                                startBtn.classList.remove('hidden'); 
                                                stopBtn.classList.add('hidden'); 
                                                timerDisplay.textContent = formatTimerDisplay(storedTimer.duration); 
                                            } else {
                                                timerDisplay.textContent = formatTimerDisplay(currentRemaining); 
                                            }
                                        }, 1000)
                                    };
                                    // Update display immediately and set active class
                                    timerDisplay.textContent = formatTimerDisplay(remainingSeconds);
                                    timerDisplay.classList.add('timer-active');
                                    // Adjust button visibility
                                    startBtn.classList.add('hidden');
                                    stopBtn.classList.remove('hidden');
                                } else {
                                    // If the exercise element is no longer in the DOM (e.g., session changed or exercise deleted), clean up localStorage
                                    localStorage.removeItem(key);
                                }
                            } else {
                                // Timer has effectively expired, clean up localStorage
                                localStorage.removeItem(key);
                            }
                        } else {
                            // Invalid or expired stored data, clean up localStorage
                            localStorage.removeItem(key);
                        }
                    } catch (e) {
                        console.error(`Error parsing stored timer data for key ${key}:`, e);
                        localStorage.removeItem(key); // Remove corrupted data
                    }
                }
            }
        }
        
        function setupEventListeners() {
            dom.sessionSelect.addEventListener('change', async () => {
                const lastSavedIndex = state.currentSessionIndex;
                if (localStorage.getItem('inProgressWorkout')) {
                    const confirmed = await customConfirm("Changer de sÃ©ance annulera la sÃ©ance en cours. Toutes les donnÃ©es non sauvegardÃ©es seront perdues. Continuer ?");
                    if (!confirmed) {
                        dom.sessionSelect.value = lastSavedIndex;
                        return;
                    }
                    // Clear all individual timers
                    for (const timerKey in state.timers) {
                        if (state.timers[timerKey] && state.timers[timerKey].interval) {
                            clearInterval(state.timers[timerKey].interval);
                            localStorage.removeItem(`timer-${timerKey}`); // Clear individual timer from storage
                        }
                    }
                    state.timers = {}; // Reset timers object
                    if (state.totalWorkoutTimeInterval) {
                        clearInterval(state.totalWorkoutTimeInterval);
                        state.totalWorkoutTimeInterval = null;
                    }
                    state.workoutStartTime = null;
                    state.isWorkoutTimerPaused = false;
                    state.pausedTime = 0;
                    dom.timerPlayPauseIcon.textContent = 'â¶ï¸';
                    dom.timerPlayPauseText.textContent = 'Play';
                    localStorage.removeItem('inProgressWorkout');
                    dom.totalTimeEl.textContent = "00:00:00";
                    dom.totalTonnageEl.textContent = "0 kg"; 
                    dom.deltaEl.textContent = "0 kg"; 
                    dom.previousWeekInput.value = "";
                    dom.sessionNotesInput.value = ""; 
                }
                state.currentSessionIndex = +dom.sessionSelect.value;
                createTable();
                updateDeleteSessionButtonState(); // Update delete button state on session change
            });
            
            dom.addExerciseBtn.addEventListener('click', () => {
                const name = dom.customExerciseInput.value.trim();
                if (name) {
                    updateStateFromTable();
                    if (!state.sessions[state.currentSessionIndex].exercises) {
                        state.sessions[state.currentSessionIndex].exercises = [];
                    }
                    state.sessions[state.currentSessionIndex].exercises.push({ name, rest: "1 min", series: [] });
                    createTable(); 
                    dom.customExerciseInput.value = '';
                    showNotification(`Exercice "${name}" ajoutÃ© avec succÃ¨s.`, "info");
                    dom.autocompleteSuggestions.classList.remove('show');
                    dom.autocompleteSuggestions.addEventListener('transitionend', () => {
                        dom.autocompleteSuggestions.classList.add('hidden');
                        dom.autocompleteSuggestions.innerHTML = ''; 
                    }, { once: true });
                    const newElement = document.querySelector(`[data-exercise-index="${state.sessions[state.currentSessionIndex].exercises.length - 1}"]`);
                    if (newElement) {
                        newElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
                    }
                } else {
                    showNotification("Veuillez entrer un nom d'exercice Ã  ajouter.", "error");
                }
            });

            dom.customExerciseInput.addEventListener('input', () => showSuggestions(dom.customExerciseInput));
            dom.customExerciseInput.addEventListener('blur', () => {
                // Delay hiding to allow click on suggestion
                setTimeout(() => dom.autocompleteSuggestions.classList.remove('show'), 100); 
                setTimeout(() => dom.autocompleteSuggestions.classList.add('hidden'), 300);
            });
            dom.customExerciseInput.addEventListener('focus', () => showSuggestions(dom.customExerciseInput));
            document.addEventListener('click', hideSuggestionsOnClickOutside);
            dom.autocompleteSuggestions.addEventListener('mousedown', (e) => e.preventDefault());

            dom.exerciseListContainer.addEventListener('blur', (e) => {
                if (e.target.classList.contains('reps')) {
                    handleRepInput(e);
                }
            }, true);


            dom.exerciseListContainer.addEventListener('input', e => { 
                if (e.target.classList.contains('reps') || e.target.classList.contains('weight')) {
                    if (!state.workoutStartTime) {
                        startTotalWorkoutTimer();
                    }
                    updateAllTotals(); 
                    // No auto-focus on input event anymore
                }
            });

            // [FIX #2] - Modified keydown event listener
            dom.exerciseListContainer.addEventListener('keydown', e => {
                if (e.key === 'Enter') {
                    const target = e.target;
                    // Check if the target is a weight or reps input field
                    if (target.classList.contains('weight') || target.classList.contains('reps')) {
                        e.preventDefault(); // Prevent default Enter behavior (e.g., submitting a form)

                        const exIndex = parseInt(target.dataset.ex, 10);
                        const serieIndex = parseInt(target.dataset.serie, 10);

                        // Inline validation for the current input
                        if (!isValidAndCompleteNumber(target.value)) {
                            target.classList.add('is-invalid');
                            return; // Stop if the current input is invalid
                        } else {
                            target.classList.remove('is-invalid');
                        }

                        if (target.classList.contains('weight')) {
                            // If weight is entered and valid, move to reps of the same set
                            const repsInput = document.querySelector(`[data-ex='${exIndex}'][data-serie='${serieIndex}'].reps`);
                            if (repsInput) {
                                repsInput.focus();
                            }
                        } else if (target.classList.contains('reps')) {
                            // This block runs when Enter is pressed on a valid reps input
                            const weightInput = document.querySelector(`[data-ex='${exIndex}'][data-serie='${serieIndex}'].weight`);
                            
                            // Check if BOTH weight and reps for the CURRENT set are valid and complete
                            if (weightInput && isValidAndCompleteNumber(weightInput.value) && isValidAndCompleteNumber(target.value)) {
                                
                                // Trigger superset timer if applicable
                                const currentExercise = state.sessions[state.currentSessionIndex].exercises[exIndex];
                                const element = target.closest('.exercise-row') || target.closest('.exercise-card');
                                if (currentExercise.supersetGroup) {
                                    handleTimerActions('start', exIndex, element);
                                }

                                // Move to the NEXT series' weight input
                                const nextWeightInput = document.querySelector(`[data-ex='${exIndex}'][data-serie='${serieIndex + 1}'].weight`);
                                if (nextWeightInput) {
                                    if (nextWeightInput.value.trim() === '') { // Only pre-fill if empty
                                        nextWeightInput.value = weightInput.value; // Pre-fill with previous weight
                                    }
                                    nextWeightInput.focus();
                                } else {
                                    // No more series in this exercise, try next exercise's first weight input
                                    const nextExerciseElement = document.querySelector(`[data-exercise-index="${exIndex + 1}"]`);
                                    if (nextExerciseElement) {
                                        const firstWeightInputOfNextEx = nextExerciseElement.querySelector(`.weight[data-serie="0"]`);
                                        if (firstWeightInputOfNextEx) {
                                            // Do not pre-fill weight from a different exercise
                                            firstWeightInputOfNextEx.focus();
                                        } else {
                                            target.blur(); // No next input found, just blur
                                        }
                                    } else {
                                        target.blur(); // No next exercise, just blur
                                    }
                                }
                            }
                        }
                    }
                }
            });


            dom.previousWeekInput.addEventListener('input', updateAllTotals); 
            dom.exerciseListContainer.addEventListener('click', handleTableActions); 
            document.getElementById('finishSessionBtn').addEventListener('click', finishAndSaveSession);
            document.getElementById('viewHistoryBtn').addEventListener('click', () => {
                const triggeringElement = document.activeElement; // Save element that triggered the modal
                displayHistory(); 
                dom.historyModal.classList.remove('hidden'); 
                dom.historyModal.classList.add('show');
                // Accessibility: Ensure focus is trapped within the modal and moved to the first interactive element.
                dom.closeHistoryModal.focus(); 
                // Restore focus when modal closes
                dom.historyModal.addEventListener('transitionend', () => {
                    if (dom.historyModal.classList.contains('hidden') && triggeringElement && typeof triggeringElement.focus === 'function') {
                        triggeringElement.focus();
                    }
                }, { once: true });
            });
            dom.historyModal.addEventListener('click', handleHistoryActions);
            dom.exportBtn.addEventListener('click', exportCSV); 
            dom.importBtn.addEventListener('click', () => dom.importFileInput.click());

            // Import file logic
            dom.importFileInput.addEventListener('change', (event) => {
                const file = event.target.files[0];
                if (!file) {
                    showNotification("Aucun fichier sÃ©lectionnÃ© pour l'importation.", "info");
                    return;
                }

                const reader = new FileReader();
                reader.onload = async (e) => {
                    try {
                        const content = e.target.result;
                        let importedData;

                        if (file.name.endsWith('.json')) {
                            importedData = JSON.parse(content);
                        } else if (file.name.endsWith('.csv')) {
                            importedData = parseCsvToHistory(content);
                        } else {
                            showNotification("Format de fichier non pris en charge. Veuillez utiliser un fichier .json ou .csv.", "error");
                            return;
                        }

                        // Merge imported data with existing history
                        let currentHistory = getHistory();
                        let newEntriesCount = 0;
                        let updatedEntriesCount = 0;
                        
                        importedData.forEach(importedSession => {
                            const existingIndex = currentHistory.findIndex(s => s.id === importedSession.id);
                            if (existingIndex !== -1) {
                                currentHistory[existingIndex] = importedSession;
                                updatedEntriesCount++;
                            } else {
                                currentHistory.push(importedSession);
                                newEntriesCount++;
                            }
                        });

                        localStorage.setItem('workoutHistory', JSON.stringify(currentHistory));
                        displayHistory();
                        showNotification(`${newEntriesCount} sÃ©ances importÃ©es et ${updatedEntriesCount} mises Ã  jour avec succÃ¨s.`, "success");

                    } catch (error) {
                        console.error("Erreur lors de l'importation du fichier:", error);
                        showNotification("Une erreur est survenue lors du traitement du fichier. Veuillez vÃ©rifier son format.", "error");
                    } finally {
                        event.target.value = ''; // Clear the input so same file can be selected again
                    }
                };
                reader.readAsText(file, 'UTF-8');
            });

            document.getElementById('closeHistoryModal').addEventListener('click', () => {
                dom.historyModal.classList.remove('show');
                const triggeringElement = document.activeElement; // Save element that triggered the modal
                dom.historyModal.addEventListener('transitionend', () => {
                    dom.historyModal.classList.add('hidden');
                    if (triggeringElement && typeof triggeringElement.focus === 'function') {
                        triggeringElement.focus();
                    }
                }, { once : true });
            });
            dom.themeToggleBtn.addEventListener('click', () => {
                const newTheme = dom.body.classList.contains('dark-mode') ? 'light' : 'dark';
                applyTheme(newTheme);
                localStorage.setItem('theme', newTheme);
            });
            dom.toggleWorkoutTimerBtn.addEventListener('click', () => {
                if (state.isWorkoutTimerPaused) {
                    startTotalWorkoutTimer();
                } else {
                    pauseTotalWorkoutTimer();
                }
            });
            dom.createNewSessionTypeBtn.addEventListener('click', showNewSessionModal);
            dom.deleteCurrentSessionBtn.addEventListener('click', deleteCurrentSession); // New listener for delete button
            dom.closeNewSessionModal.addEventListener('click', hideNewSessionModal);
            dom.cancelNewSessionBtn.addEventListener('click', hideNewSessionModal);
            dom.createNewSessionBtn.addEventListener('click', createNewSession);
            dom.closeLoadOptionsModal.addEventListener('click', hideLoadOptionsModal);
            dom.openNewSessionBtn.addEventListener('click', async () => { 
                if (state.sessionToLoad) await openNewSessionLogic(state.sessionToLoad);
            });
            dom.appendToCurrentSessionBtn.addEventListener('click', async () => { 
                if (state.sessionToLoad) await appendToCurrentSessionLogic(state.sessionToLoad);
            });
            dom.plateCalculatorBtn.addEventListener('click', () => {
                const triggeringElement = document.activeElement; // Save element that triggered the modal
                dom.plateCalculatorModal.classList.remove('hidden');
                dom.plateCalculatorModal.classList.add('show');
                 // Accessibility: Set focus to the first interactive element in the calculator modal
                const firstInput = dom.plateCalculatorModal.querySelector('input, button');
                if (firstInput) firstInput.focus();
                // Restore focus when modal closes
                dom.plateCalculatorModal.addEventListener('transitionend', () => {
                    if (dom.plateCalculatorModal.classList.contains('hidden') && triggeringElement && typeof triggeringElement.focus === 'function') {
                        triggeringElement.focus();
                    }
                }, { once: true });
            });
            dom.closePlateCalculatorModal.addEventListener('click', () => {
                dom.plateCalculatorModal.classList.remove('show');
                const triggeringElement = document.activeElement; // Save element that triggered the modal
                dom.plateCalculatorModal.addEventListener('transitionend', () => {
                    dom.plateCalculatorModal.classList.add('hidden');
                    if (triggeringElement && typeof triggeringElement.focus === 'function') {
                        triggeringElement.focus();
                    }
                }, { once : true });
            });
            dom.targetWeightInput.addEventListener('input', calculatePlates);
            dom.barbellWeightInput.addEventListener('input', calculatePlates);
            
            // New Event Listeners for Goal Calculator
            dom.plateCalcTab.addEventListener('click', () => {
                dom.plateCalcTab.classList.add('active');
                dom.plateCalcTab.setAttribute('aria-selected', 'true');
                dom.goalCalcTab.classList.remove('active');
                dom.goalCalcTab.setAttribute('aria-selected', 'false');
                dom.plateCalcContent.classList.remove('hidden');
                dom.goalCalcContent.classList.add('hidden');
                 // Accessibility: Set focus to the first interactive element in the active tab
                const firstInput = dom.plateCalcContent.querySelector('input, button');
                if (firstInput) firstInput.focus();
            });

            dom.goalCalcTab.addEventListener('click', () => {
                dom.goalCalcTab.classList.add('active');
                dom.goalCalcTab.setAttribute('aria-selected', 'true');
                dom.plateCalcTab.classList.remove('active');
                dom.plateCalcTab.setAttribute('aria-selected', 'false');
                dom.goalCalcContent.classList.remove('hidden');
                dom.plateCalcContent.classList.add('hidden');
                // Accessibility: Set focus to the first interactive element in the active tab
                const firstInput = dom.goalCalcContent.querySelector('input, button');
                if (firstInput) firstInput.focus();
            });

            dom.oneRmInput.addEventListener('input', calculateTrainingGoals);

            // Quick Edit Modal Listeners
            dom.closeQuickEditModal.addEventListener('click', () => {
                dom.quickEditModal.classList.remove('show');
                const triggeringElement = document.activeElement; // Save element that triggered the modal
                dom.quickEditModal.addEventListener('transitionend', () => {
                    dom.quickEditModal.classList.add('hidden');
                    if (triggeringElement && typeof triggeringElement.focus === 'function') {
                        triggeringElement.focus();
                    }
                }, { once : true });
            });
            dom.applyQuickEditBtn.addEventListener('click', () => {
                const weightValid = validateInputField(dom.quickEditWeight, dom.quickEditWeightError, true); // Allow empty for quick edit
                const repsValid = validateInputField(dom.quickEditReps, dom.quickEditRepsError, true); // Allow empty for quick edit

                if (!weightValid || !repsValid) {
                    showNotification("Veuillez corriger les erreurs pour appliquer l'Ã©dition rapide.", "error");
                    return;
                }

                if (state.quickEditIndex !== null) {
                    const weight = dom.quickEditWeight.value;
                    const reps = dom.quickEditReps.value;
                    for (let i = 0; i < 5; i++) {
                        const weightInput = document.querySelector(`[data-ex='${state.quickEditIndex}'][data-serie='${i}'].weight`);
                        const repsInput = document.querySelector(`[data-ex='${state.quickEditIndex}'][data-serie='${i}'].reps`);
                        if(weightInput) weightInput.value = weight;
                        if(repsInput) repsInput.value = reps;
                    }
                    updateAllTotals();
                    dom.quickEditModal.classList.remove('show');
                    const triggeringElement = document.activeElement; // Save element that triggered the modal
                    dom.quickEditModal.addEventListener('transitionend', () => {
                        dom.quickEditModal.classList.add('hidden');
                        if (triggeringElement && typeof triggeringElement.focus === 'function') {
                            triggeringElement.focus();
                        }
                    }, { once : true });
                    showNotification("SÃ©ries mises Ã  jour rapidement !", "success");
                }
            });

            document.addEventListener('keydown', e => {
                if (e.ctrlKey || e.metaKey) { 
                    if (e.key === 's') { e.preventDefault(); finishAndSaveSession(); } 
                    if (e.key === 'e') { e.preventDefault(); exportCSV(); } 
                }
                if (e.key === 'Escape') { 
                    if (dom.historyModal.classList.contains('show')) {
                        dom.historyModal.classList.remove('show');
                        dom.historyModal.addEventListener('transitionend', () => dom.historyModal.classList.add('hidden'), { once : true });
                    }
                    if (dom.newSessionModal.classList.contains('show')) {
                        dom.newSessionModal.classList.remove('show');
                        dom.newSessionModal.addEventListener('transitionend', () => dom.newSessionModal.classList.add('hidden'), { once : true });
                    }
                    if (dom.loadOptionsModal.classList.contains('show')) {
                        hideLoadOptionsModal();
                    }
                    if (dom.plateCalculatorModal.classList.contains('show')) {
                        dom.plateCalculatorModal.classList.remove('show');
                        dom.plateCalculatorModal.addEventListener('transitionend', () => dom.plateCalculatorModal.classList.add('hidden'), { once : true });
                    }
                    if (dom.quickEditModal.classList.contains('show')) {
                        dom.quickEditModal.classList.remove('show');
                        dom.quickEditModal.addEventListener('transitionend', () => dom.quickEditModal.classList.add('hidden'), { once : true });
                    }
                    if (dom.pwaInstallPrompt.classList.contains('show')) { // Close PWA prompt on Escape
                        dom.pwaInstallPrompt.classList.remove('show');
                        dom.pwaInstallPrompt.addEventListener('transitionend', () => dom.pwaInstallPrompt.classList.add('hidden'), { once: true });
                        localStorage.setItem('pwaPromptDismissed', 'true');
                    }
                }
            });

            // Bottom navigation listeners
            dom.bottomAddExerciseBtn.addEventListener('click', () => {
                dom.addExerciseSection.scrollIntoView({ behavior: 'smooth' });
                setTimeout(() => {
                    dom.customExerciseInput.focus();
                }, 300);
            });
            dom.bottomNotesBtn.addEventListener('click', () => {
                state.isNotesSectionVisible = !state.isNotesSectionVisible;
                if (state.isNotesSectionVisible) {
                    dom.sessionNotesSection.classList.remove('hide-notes-section');
                    dom.sessionNotesSection.classList.add('show-notes-section');
                    dom.sessionNotesInput.focus();
                    dom.sessionNotesSection.scrollIntoView({ behavior: 'smooth', block: 'center' });
                } else {
                    dom.sessionNotesSection.classList.remove('show-notes-section');
                    dom.sessionNotesSection.classList.add('hide-notes-section');
                }
            });
            dom.bottomFinishSessionBtn.addEventListener('click', finishAndSaveSession);
            dom.bottomViewHistoryBtn.addEventListener('click', () => {
                displayHistory(); 
                dom.historyModal.classList.remove('hidden'); 
                dom.historyModal.classList.add('show');
                dom.closeHistoryModal.focus(); // Focus close button for accessibility
            });
            dom.bottomPlateCalculatorBtn.addEventListener('click', () => {
                dom.plateCalculatorModal.classList.remove('hidden');
                dom.plateCalculatorModal.classList.add('show');
                dom.closePlateCalculatorModal.focus(); // Focus close button for accessibility
            });
        }
        
        function init() {
            if ('Notification' in window) {
                Notification.requestPermission();
            }

            state.availableExercises = parseExerciseList(rawExerciseList);

            const savedTheme = localStorage.getItem('theme');
            if (savedTheme) {
                applyTheme(savedTheme);
            } else {
                const prefersDark = window.matchMedia('(prefers-color-scheme: dark)');
                applyTheme(prefersDark.matches ? 'dark' : 'light');
                prefersDark.addEventListener('change', (e) => {
                    if (!localStorage.getItem('theme')) {
                        applyTheme(e.matches ? 'dark' : 'light');
                    }
                });
            }
            
            const inProgress = JSON.parse(localStorage.getItem('inProgressWorkout'));
            if (inProgress) {
                state.sessions = inProgress.customSessions || JSON.parse(JSON.stringify(defaultSessions));
                state.currentSessionIndex = inProgress.sessionIndex || 0;
                if (state.currentSessionIndex >= state.sessions.length) {
                    state.currentSessionIndex = 0;
                }
                
                state.workoutStartTime = inProgress.workoutStartTime || null;
                state.isWorkoutTimerPaused = inProgress.isWorkoutTimerPaused;
                state.pausedTime = inProgress.pausedTime || 0;
                
                if (state.workoutStartTime && !state.isWorkoutTimerPaused) {
                    // Recalculate pausedTime on load if timer was active when closed
                    // This uses the saved timestamp to estimate elapsed time since last save
                    const elapsedSinceSave = (Date.now() - (inProgress.saveTimestamp || new Date(state.workoutStartTime).getTime())) / 1000;
                    state.pausedTime = (inProgress.pausedTime || 0) + elapsedSinceSave;
                    startTotalWorkoutTimer();
                } else if (state.workoutStartTime) {
                    dom.totalTimeEl.textContent = formatTime(state.pausedTime);
                    dom.timerPlayPauseIcon.textContent = 'â¶ï¸';
                    dom.timerPlayPauseText.textContent = 'Play';
                }
            } else {
                 state.sessions = JSON.parse(JSON.stringify(defaultSessions));
            }
            
            // Initialize notes section visibility on mobile
            if (state.isMobileView) {
                dom.sessionNotesSection.classList.add('hide-notes-section'); // Initially hidden on mobile
                state.isNotesSectionVisible = false;
            } else {
                dom.sessionNotesSection.classList.add('show-notes-section'); // Always visible on desktop
                state.isNotesSectionVisible = true;
            }

            updateSessionSelectOptions(); 
            dom.sessionSelect.value = state.currentSessionIndex;
            createTable();
            setupEventListeners();
            loadPersistentIndividualTimers(); // Load and resume individual timers on initialization

            // Listen for window resize to toggle between desktop table and mobile cards
            window.addEventListener('resize', () => {
                const newIsMobileView = window.matchMedia("(max-width: 768px)").matches;
                if (newIsMobileView !== state.isMobileView) {
                    state.isMobileView = newIsMobileView;
                    createTable(); // Re-render table/cards based on new view state
                    // Adjust notes section visibility based on new view state
                    if (state.isMobileView && !state.isNotesSectionVisible) {
                        dom.sessionNotesSection.classList.add('hide-notes-section');
                    } else {
                        dom.sessionNotesSection.classList.remove('hide-notes-section');
                        dom.sessionNotesSection.classList.add('show-notes-section');
                    }
                }
            });
        }

        init();
    });
    </script>
    <script>
    // PWA: Service Worker File (service-worker.js)
    // This content would typically be in a separate file, but is included here for demonstration.
    // In a real PWA, you would save this as /service-worker.js
    
    self.addEventListener('install', (event) => {
      event.waitUntil(
        caches.open('lyftiv-cache-v1').then((cache) => {
          return cache.addAll([
            '/', // Cache the root of the app
            '/index.html', // Your main HTML file
            // Add other critical assets here (CSS, JS, images, fonts)
            'https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&display=swap',
            'https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css',
            'https://unpkg.com/@phosphor-icons/web@2.1.1/src/fill/style.css',
            // Any other JS or image assets used
          ]);
        })
      );
    });

    self.addEventListener('fetch', (event) => {
      event.respondWith(
        caches.match(event.request).then((response) => {
          return response || fetch(event.request);
        })
      );
    });
    </script>
    <script type="application/json" id="manifest-json">
    {
      "name": "Lyftiv",
      "short_name": "Lyftiv",
      "description": "Suivi de SÃ©ance Musculation",
      "start_url": "./index.html",
      "display": "standalone",
      "background_color": "#eff6ff",
      "theme_color": "#6a90ff",
      "icons": [
        {
          "src": "/icons/icon-192x192.png",
          "sizes": "192x192",
          "type": "image/png"
        },
        {
          "src": "/icons/icon-512x512.png",
          "sizes": "512x512",
          "type": "image/png"
        }
      ]
    }
    </script>
</body>
</html>
