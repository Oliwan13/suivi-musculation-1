<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    
    <meta name="robots" content="noindex, nofollow">
    <!-- CSP is intentionally kept minimal to allow inline scripts for demonstration purposes. -->
    <meta http-equiv="Content-Security-Policy" content="default-src 'self'; style-src 'self' 'unsafe-inline'; script-src 'self' 'unsafe-inline';">

    <title>Suivi S√©ance Musculation - Enhanced v4</title>
    
    <style>
        :root {
            --bg-grad-start: #667eea;
            --bg-grad-end: #764ba2;
            --container-bg: rgba(255, 255, 255, 0.95);
            --text-color: #333;
            --header-color: #4a5568;
            --border-color: #e2e8f0;
            --row-bg-even: rgba(248, 250, 252, 0.8);
            --input-bg: white;
            --primary-grad-start: #667eea; /* Light mode primary button start color */
            --primary-grad-end: #764ba2;   /* Light mode primary button end color */
            --success-grad-start: #48bb78;
            --success-grad-end: #38a169;
            --warning-grad-start: #ed8936;
            --warning-grad-end: #dd6b20;
            --danger-grad-start: #f56565;
            --danger-grad-end: #e53e3e;
            --info-grad-start: #4299e1;
            --info-grad-end: #3182ce;
            --text-on-color: white;
        }

        body.dark-mode {
            --bg-grad-start: #1a202c;
            --bg-grad-end: #2d3748;
            --container-bg: rgba(45, 55, 72, 0.95);
            --text-color: #e2e8f0;
            --header-color: #a0aec0;
            --border-color: #4a5568;
            --row-bg-even: rgba(26, 32, 44, 0.8);
            --input-bg: #2d3748;
            --primary-grad-start: #4c5a6b; /* Dark mode primary button start color */
            --primary-grad-end: #606d7d;   /* Dark mode primary button end color */
        }

        * { box-sizing: border-box; }
        body {
            font-family: 'Inter', sans-serif;
            font-size: 16px; /* Base font size */
            line-height: 1.6; /* Improved readability */
            margin: 0;
            padding: 1rem;
            background: linear-gradient(135deg, var(--bg-grad-start) 0%, var(--bg-grad-end) 100%);
            min-height: 100vh;
            color: var(--text-color);
            transition: background 0.3s, color 0.3s;
        }
        .main-container {
            max-width: 1600px;
            margin: 0 auto;
            background: var(--container-bg);
            border-radius: 20px;
            padding: 2rem;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
            backdrop-filter: blur(10px);
            transition: background 0.3s;
            position: relative; /* Added for positioning theme switcher */
        }
        h2 {
            text-align: center;
            color: var(--header-color);
            margin-bottom: 2rem;
            font-size: 2rem;
            font-weight: 700; /* Bolder for titles */
            display: flex; /* Allow flexbox for centering SVG */
            align-items: center; /* Vertically align items */
            justify-content: center; /* Horizontally center items */
            gap: 0.5rem; /* Space between SVG and text */
        }
        h3 {
            font-weight: 600; /* Slightly less bold than h2 */
            color: var(--header-color);
        }
        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 1rem;
            align-items: center;
            margin-bottom: 1rem;
            padding: 1rem;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
        }
        select, input[type="number"], input[type="text"] {
            padding: 0.75rem; /* Slightly larger padding for better touch targets */
            border: 2px solid var(--border-color);
            border-radius: 8px;
            font-size: 1rem;
            background-color: var(--input-bg);
            color: var(--text-color);
            font-weight: 500; /* Medium weight for input text */
            width: 100%; /* Make input elements responsive */
            max-width: 250px; /* Limit width on larger screens */
        }
        .table-container {
            overflow-x: auto;
            border-radius: 15px;
            background: var(--input-bg);
            margin-bottom: 2rem;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            min-width: 1000px; /* Adjusted minimum width for the table */
        }
        th, td {
            padding: 1rem 0.5rem;
            text-align: center;
            border-bottom: 1px solid var(--border-color);
        }
        th {
            background: linear-gradient(135deg, var(--primary-grad-start), var(--primary-grad-end));
            color: var(--text-on-color);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            position: sticky;
            top: 0;
            z-index: 10;
            font-weight: 700; /* Bolder for table headers */
        }
        .fixed-col {
            position: sticky;
            left: 0;
            background: inherit;
            min-width: 110px; /* Reduced min-width for better column balance */
            text-align: left;
            padding-left: 1rem;
            font-weight: 600;
            white-space: nowrap; /* Prevent text wrapping */
            overflow: hidden; /* Hide overflow content */
            text-overflow: ellipsis; /* Add ellipsis for hidden content */
        }
        .exercise-row:nth-child(even) { background: var(--row-bg-even); }
        .serie-input {
            display: flex; /* Use flexbox for reps and weight inputs */
            flex-direction: column; /* Stack them vertically on small screens */
            gap: 0.2rem; /* Small gap between them */
            align-items: center; /* Center items in the column */
        }
        .serie-input input {
            width: 70px; /* Slightly reduced width for better fit */
            padding: 0.5rem; /* Reduced padding */
            font-size: 0.9rem; /* Slightly larger font */
            text-align: center;
            font-weight: 500;
        }
        .serie-input input.completed {
            background: linear-gradient(135deg, var(--success-grad-start), var(--success-grad-end));
            color: var(--text-on-color);
            border-color: var(--success-grad-end);
        }
        .tonnage-high, .onerm-high {
            background: linear-gradient(135deg, var(--success-grad-start), var(--success-grad-end));
            color: var(--text-on-color);
            border-radius: 6px;
            padding: 0.5rem;
            font-weight: 600;
        }
        .timer-btn {
            padding: 0.8rem 1.2rem; /* Larger padding for buttons */
            border: none;
            border-radius: 25px; /* More rounded */
            cursor: pointer;
            font-size: 1rem; /* Larger font size */
            font-weight: 600;
            transition: all 0.2s ease;
            min-width: 60px; /* Ensure a minimum tap target size */
            text-align: center;
        }
        .timer-btn:hover { transform: translateY(-2px); box-shadow: 0 4px 8px rgba(0,0,0,0.2); }
        .timer-btn[data-timer-action="start"] { background: linear-gradient(135deg, var(--success-grad-start), var(--success-grad-end)); color: var(--text-on-color); }
        .timer-btn[data-timer-action="stop"] { background: linear-gradient(135deg, var(--danger-grad-start), var(--danger-grad-end)); color: var(--text-on-color); }
        .timer-btn[data-timer-action="reset"] { background: linear-gradient(135deg, var(--warning-grad-start), var(--warning-grad-end)); color: var(--text-on-color); }
        .timer-display.timer-active { color: var(--success-grad-start); animation: pulse 1s infinite; }
        @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.7; } }
        .summary-section {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 1rem;
            margin-bottom: 2rem;
        }
        .summary-card { padding: 1.5rem; border-radius: 15px; text-align: center; background: rgba(255, 255, 255, 0.05); }
        .summary-card .value { font-size: 2rem; font-weight: bold; color: var(--primary-grad-start); }
        .action-buttons { display: flex; flex-wrap: wrap; gap: 1rem; justify-content: center; margin-top: 2rem; }
        .btn { padding: 0.8rem 1.5rem; border: none; border-radius: 25px; cursor: pointer; font-size: 1rem; font-weight: 600; color: var(--text-on-color); }
        .btn-primary { 
            background: linear-gradient(135deg, var(--primary-grad-start), var(--primary-grad-end));
            transition: background 0.3s ease; /* Smooth transition for background change */
        }
        .btn-secondary { background: linear-gradient(135deg, var(--warning-grad-start), var(--warning-grad-end)); }
        .btn-danger { background: linear-gradient(135deg, var(--danger-grad-start), var(--danger-grad-end)); }
        .btn-success { background: linear-gradient(135deg, var(--success-grad-start), var(--success-grad-end)); }
        .notification { position: fixed; top: 20px; right: 20px; padding: 1rem 1.5rem; border-radius: 10px; color: var(--text-on-color); z-index: 1001; transform: translateX(400px); transition: transform 0.3s ease; }
        .notification.show { transform: translateX(0); }
        .notification.success { background: linear-gradient(135deg, var(--success-grad-start), var(--success-grad-end)); }
        .notification.error { background: linear-gradient(135deg, var(--danger-grad-start), var(--danger-grad-end)); }
        .notification.info { background: linear-gradient(135deg, var(--info-grad-start), var(--info-grad-end)); }
        .modal-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.6); display: flex; align-items: center; justify-content: center; z-index: 1000; backdrop-filter: blur(5px); }
        .modal-content { background: var(--container-bg); padding: 2rem; border-radius: 15px; max-width: 800px; max-height: 90vh; overflow-y: auto; position: relative; }
        .modal-close-btn { position: absolute; top: 1rem; right: 1rem; background: var(--border-color); color: var(--text-color); border: none; border-radius: 50%; width: 30px; height: 30px; font-size: 1.2rem; cursor: pointer; }
        #historyList { display: flex; flex-direction: column; gap: 1rem; }
        .history-item { border: 1px solid var(--border-color); border-radius: 10px; padding: 1rem; display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 1rem; }
        .history-details { display: none; width: 100%; margin-top: 1rem; padding-top: 1rem; border-top: 1px solid var(--border-color); }
        .history-details.visible { display: block; }
        .progress-bar { width: 100%; height: 8px; background: var(--border-color); border-radius: 4px; overflow: hidden; margin: 1rem 0; }
        .progress-fill { height: 100%; background: linear-gradient(135deg, var(--success-grad-start), var(--success-grad-end)); border-radius: 4px; transition: width 0.5s ease; }
        .hidden { display: none !important; }
        .theme-switcher { 
            position: absolute; 
            top: 1rem; 
            right: 1rem;
            z-index: 11; /* Ensure it's above other elements */
        }
        .total-time-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.5rem;
        }
        .add-exercise-section {
            display: flex;
            justify-content: center; /* Center the input and button */
            gap: 1rem;
            margin-top: 1rem; /* Add some space above */
            padding: 1rem; /* Match controls padding */
            background: rgba(255, 255, 255, 0.05); /* Match controls background */
            border-radius: 15px; /* Match controls border-radius */
        }
        .add-exercise-section input[type="text"] {
            flex-grow: 1; /* Allow input to take available space */
            max-width: 400px; /* Limit max width for better aesthetics */
        }
        /* Adjusted style for the delete button (now just 'X') */
        .btn-danger[data-action="remove"] {
            background: none; /* Remove background */
            color: var(--danger-grad-end); /* Use danger color for the X */
            padding: 0.2rem 0.5rem; /* Reduce padding to make it less like a solid button */
            border: 1px solid transparent; /* Keep a transparent border for consistency with other inputs */
            font-size: 1.2rem;
            font-weight: 700;
        }
        .btn-danger[data-action="remove"]:hover {
            background: rgba(255, 0, 0, 0.1); /* Subtle hover effect */
            transform: none; /* Remove translation effect */
            box-shadow: none; /* Remove box shadow */
        }

        /* Responsive adjustments for smaller screens */
        @media (max-width: 768px) {
            body {
                padding: 0.5rem;
                padding-bottom: 70px; /* Added padding to ensure last button is visible */
                font-size: 14px; /* Smaller base font for mobile */
            }
            .main-container {
                padding: 1rem;
            }
            h2 {
                font-size: 1.5rem; /* Smaller title for mobile */
                margin-top: 2rem; /* Add space for the theme switcher */
            }
            .theme-switcher {
                position: absolute;
                top: 0.5rem; /* Adjusted to be inside the container */
                right: 0.5rem; /* Adjusted to be inside the container */
            }
            .fixed-col {
                min-width: 90px; /* Further reduced min-width for mobile */
                padding-left: 0.5rem; /* Reduced padding on mobile */
            }
            .controls {
                flex-direction: column;
                align-items: stretch;
            }
            .controls label {
                width: 100%;
                text-align: center;
            }
            select, input[type="number"], input[type="text"] {
                width: 100%; /* Full width for control inputs */
                max-width: none; /* Remove max-width constraint */
            }
            .table-container {
                overflow-x: auto; /* Keep horizontal scroll for table */
            }
            table {
                min-width: 600px; /* Adjusted minimum width for the table on mobile */
            }
            th, td {
                padding: 0.5rem 0.2rem; /* Reduce cell padding */
            }
            .serie-input {
                flex-direction: column; /* Stack reps/weight vertically */
            }
            .serie-input input {
                width: 55px; /* Adjust input width within series for mobile */
                padding: 0.3rem;
            }
            .timer-btn {
                padding: 0.6rem 0.8rem; /* Smaller padding for timer buttons */
                font-size: 0.9rem;
                min-width: 50px;
            }
            .summary-section {
                grid-template-columns: 1fr; /* Single column layout for summary on mobile */
            }
            .action-buttons {
                flex-direction: column; /* Stack action buttons vertically */
            }
            .btn {
                width: 100%; /* Full width for action buttons */
            }
            .notification {
                width: calc(100% - 20px); /* Full width less margins */
                left: 10px;
                right: 10px;
                transform: translateX(0); /* Adjust initial position */
            }
            .notification.show {
                transform: translateX(0);
            }
            .modal-content {
                width: calc(100% - 2rem);
                margin: 1rem;
            }
        }
    </style>
</head>
<body>
    <div class="main-container">
        <div class="theme-switcher">
            <button id="themeToggleBtn" class="btn btn-primary" aria-label="Switch Theme">üåô</button>
        </div>
        <h2>
            Suivi S√©ance Musculation
        </h2>
        
        <div class="controls">
          <label for="sessionSelect"><strong>S√©ance:</strong></label>
          <select id="sessionSelect">
            <option value="0">PUSH (Poitrine/√âpaules/Triceps)</option>
            <option value="1">PULL (Dos/Biceps)</option>
            <option value="2">LEG (Jambes)</option>
            <option value="3">√âpaules/Bras</option>
            <option value="4">Dos/Pec</option>
          </select>
          <button class="btn btn-primary" id="createNewSessionTypeBtn" aria-label="Cr√©er une nouvelle s√©ance">Nouvelle S√©ance</button>
        </div>
        
        <div class="progress-bar">
          <div class="progress-fill" id="progressFill"></div>
        </div>
        
        <div class="table-container">
          <table id="workoutTable">
            <thead>
              <tr>
                <th>Exercice</th>
                <th colspan="5">S√©ries</th>
                <th>Tonnage</th>
                <th>1RM</th>
                <th>Repos</th>
                <th>Minuteur</th>
                <th></th> </tr>
            </thead>
            <tbody id="tbody"></tbody>
          </table>
        </div>
        
        <div class="controls add-exercise-section">
            <input type="text" id="customExercise" placeholder="Ajouter un exercice">
            <button class="btn btn-success" id="addExerciseBtn" aria-label="Ajouter l'exercice">+</button>
        </div>

        <div class="summary-section">
            <div class="summary-card">
                <h3>üèãÔ∏è Tonnage Total</h3>
                <div class="value" id="totalTonnage">0 kg</div>
            </div>
            <div class="summary-card">
                <h3>üìä Semaine Pr√©c√©dente</h3>
                <input type="text" id="previousWeek" placeholder="Tonnage Pr√©c. (kg)">
            </div>
            <div class="summary-card">
                <h3>üìà Progression</h3>
                <div class="value" id="delta">0 kg</div>
            </div>
            <div class="summary-card">
                <h3>‚è±Ô∏è Temps Total</h3>
                <div class="total-time-container">
                    <div class="value" id="totalTime">00:00:00</div>
                    <button id="toggleWorkoutTimerBtn" class="btn btn-primary">‚èØÔ∏è Pause</button>
                </div>
            </div>
        </div>
        
        <div class="action-buttons">
          <button class="btn btn-danger" id="finishSessionBtn" aria-label="Terminer et Sauvegarder la s√©ance">‚úîÔ∏è Terminer & Sauvegarder</button>
          <button class="btn btn-primary" id="viewHistoryBtn" aria-label="Voir l'historique">üìñ Historique</button>
          <button class="btn btn-secondary" id="exportBtn" aria-label="Exporter les donn√©es">üìä Exporter</button>
          <button class="btn btn-success" id="importBtn" aria-label="Importer les donn√©es">üì• Importer</button>
        </div>
        <input type="file" id="importFile" class="hidden" accept=".json,.csv">
    </div>
    
    <div id="notification-container"></div>
    
    <div id="historyModal" class="modal-overlay hidden">
      <div class="modal-content">
          <button id="closeHistoryModal" class="modal-close-btn" aria-label="Fermer le modal historique">&times;</button>
          <h2>Historique des S√©ances</h2>
          <div id="historyList"></div>
      </div>
    </div>

    <div id="newSessionModal" class="modal-overlay hidden">
        <div class="modal-content">
            <button id="closeNewSessionModal" class="modal-close-btn" aria-label="Fermer le modal">&times;</button>
            <h2>Cr√©er une Nouvelle S√©ance</h2>
            <input type="text" id="newSessionNameInput" placeholder="Nom de la nouvelle s√©ance" class="p-2 border rounded-md w-full" aria-label="Nom de la nouvelle s√©ance">
            <div style="display: flex; justify-content: center; gap: 1rem; margin-top: 1.5rem;">
                <button class="btn btn-danger" id="cancelNewSessionBtn">Annuler</button>
                <button class="btn btn-success" id="createNewSessionBtn">Cr√©er</button>
            </div>
        </div>
    </div>

    <div id="loadOptionsModal" class="modal-overlay hidden">
      <div class="modal-content">
          <button id="closeLoadOptionsModal" class="modal-close-btn" aria-label="Fermer le modal">&times;</button>
          <h2>Options de Chargement de S√©ance</h2>
          <p>Comment souhaitez-vous utiliser la s√©ance "<strong id="loadSessionName"></strong>" ?</p>
          <div style="display: flex; justify-content: center; gap: 1rem; margin-top: 1.5rem;">
              <button class="btn btn-primary" id="openNewSessionBtn">Ouvrir dans une nouvelle s√©ance</button>
              <button class="btn btn-secondary" id="appendToCurrentSessionBtn">Ajouter/Mettre √† jour la s√©ance en cours</button>
          </div>
      </div>
    </div>

    <script>
    document.addEventListener('DOMContentLoaded', () => {

        const dom = {
            sessionSelect: document.getElementById('sessionSelect'),
            tbody: document.getElementById('tbody'),
            totalTonnageEl: document.getElementById('totalTonnage'),
            previousWeekInput: document.getElementById('previousWeek'),
            deltaEl: document.getElementById('delta'),
            totalTimeEl: document.getElementById('totalTime'),
            progressFill: document.getElementById('progressFill'),
            historyModal: document.getElementById('historyModal'),
            notificationContainer: document.getElementById('notification-container'),
            customExerciseInput: document.getElementById('customExercise'),
            historyList: document.getElementById('historyList'),
            importFileInput: document.getElementById('importFile'),
            themeToggleBtn: document.getElementById('themeToggleBtn'),
            body: document.body,
            toggleWorkoutTimerBtn: document.getElementById('toggleWorkoutTimerBtn'),
            newSessionModal: document.getElementById('newSessionModal'),
            closeNewSessionModal: document.getElementById('closeNewSessionModal'),
            newSessionNameInput: document.getElementById('newSessionNameInput'),
            cancelNewSessionBtn: document.getElementById('cancelNewSessionBtn'),
            createNewSessionBtn: document.getElementById('createNewSessionBtn'),
            createNewSessionTypeBtn: document.getElementById('createNewSessionTypeBtn'),
            // New DOM elements for load options modal
            loadOptionsModal: document.getElementById('loadOptionsModal'),
            closeLoadOptionsModal: document.getElementById('closeLoadOptionsModal'),
            loadSessionNameDisplay: document.getElementById('loadSessionName'),
            openNewSessionBtn: document.getElementById('openNewSessionBtn'),
            appendToCurrentSessionBtn: document.getElementById('appendToCurrentSessionBtn')
        };
        let state = {
            sessions: [],
            currentSessionIndex: 0,
            timers: {},
            workoutStartTime: null,
            totalWorkoutTimeInterval: null,
            isWorkoutTimerPaused: false,
            pausedTime: 0,
            sessionToLoad: null // Temporarily store the session selected for loading
        };
        const defaultSessions = [
            { name: "PUSH (Poitrine/√âpaules/Triceps)", exercises: [
                { name: "DC barre lourd", rest: "2 min" }, { name: "DC barre l√©ger", rest: "2 min" }, { name: "Inclin√© halt√®res", rest: "1 min" }, { name: "√âcart√© vis √† vis", rest: "1 min" }, { name: "Dips machine", rest: "1 min" }, { name: "√âl√©vation lat√©rale machine debout", rest: "1 min" }, { name: "Extension triceps poulie", rest: "1 min" }
            ]},
            { name: "PULL (Dos/Biceps)", exercises: [
                { name: "Traction", rest: "2 min" }, { name: "Pull poulie", rest: "1 min" }, { name: "Tirage uni poulie haute sur banc", rest: "1 min" }, { name: "Rowing T bar", rest: "1 min" }, { name: "Machine Row", rest: "1 min" }, { name: "Machine Row uni", rest: "1 min" }, { name: "Face pull", rest: "1 min" }, { name: "Oiseaux machine", rest: "1 min" }, { name: "Curl marteau simultan√©", rest: "1 min" }, { name: "Bayesian curl", rest: "1 min" }
            ]},
            { name: "LEG (Jambes)", exercises: [
                { name: "Leg extension drop", rest: "1 min" }, { name: "Presse horizontal", rest: "2 min" }, { name: "Squat guid√© l√©ger", rest: "1 min" }, { name: "Fente march√©", rest: "2 min" }, { name: "Leg Curl assis", rest: "1 min" }, { name: "SDT jambes tendues smith", rest: "1 min" }
            ]},
            { name: "√âpaules/Bras", exercises: [
                { name: "Militaire halt√®res pyramide montante", rest: "3 min" }, { name: "√âl√©vation lat√©rale", rest: "1 min" }, { name: "√âl√©vation lat√©rale supination", rest: "1 min" }, { name: "Face pull", rest: "1 min" }, { name: "Extension triceps", rest: "1 min" }, { name: "Curl poulie basse", rest: "1 min" }, { name: "Magic triceps", rest: "1 min" }, { name: "Curl pupitre", rest: "1 min" }, { name: "Dips", rest: "1 min" }, { name: "Curl halt√®res inclin√©", rest: "1 min" }, { name: "Cross Cable Triceps", rest: "1 min" }, { name: "Curl concentr√© halt√®re", rest: "1 min" }
            ]},
            { name: "Dos/Pec", exercises: [
                 { name: "Tirage horizontal", rest: "1 min" }, { name: "Rowing barre buste pench√© pronation", rest: "1 min" }, { name: "Tirage poulie basse avec corde", rest: "1 min" }, { name: "Inclin√© guid√©", rest: "2 min" }, { name: "√âcart√© couch√©", rest: "1 min" }, { name: "Vis √† vis sur banc inclin√©", rest: "1 min" }, { name: "Circuit abdos", rest: "1 min" }
            ]}
        ];
        /**
         * Creates and populates the main workout table based on the current session.
         */
        function createTable() {
            dom.tbody.innerHTML = "";
            const exercises = state.sessions[state.currentSessionIndex]?.exercises || []; 
            
            exercises.forEach((ex, idx) => {
                const tr = document.createElement("tr");
                tr.className = "exercise-row";
                tr.dataset.exerciseIndex = idx;

                let seriesHtml = "";
                for(let i = 0; i < 5; i++) {
                    seriesHtml += `<td><div class="serie-input">
                        <input type="number" min="0" step="0.5" data-ex="${idx}" data-serie="${i}" class="weight" placeholder="kg" aria-label="Poids pour l'exercice ${idx+1} s√©rie ${i+1}">
                        <input type="number" min="0" step="1" data-ex="${idx}" data-serie="${i}" class="reps" placeholder="Reps" aria-label="Reps pour l'exercice ${idx+1} s√©rie ${i+1}">
                    </div></td>`;
                }
                
                tr.innerHTML = `
                    <td class="fixed-col">${ex.name}</td>
                    ${seriesHtml}
                    <td id="tonnage-${idx}">0</td>
                    <td id="onerm-${idx}">0</td>
                    <td><strong>${ex.rest}</strong></td>
                    <td>
                        <div class="timer-container">
                            <div class="timer-display" id="timer-${idx}">0:00</div>
                            <button class="timer-btn" data-timer-action="start" aria-label="D√©marrer le minuteur">‚ñ∂</button>
                            <button class="timer-btn hidden" data-timer-action="stop" aria-label="Arr√™ter le minuteur">‚ñ†</button>
                            <button class="timer-btn" data-timer-action="reset" aria-label="R√©initialiser le minuteur">‚ü≤</button>
                        </div>
                    </td>
                    <td><button class="btn-danger" data-action="remove">‚ùå</button></td>`;
                dom.tbody.appendChild(tr);
            });
        }

        /**
         * Calculates the estimated 1 Rep Max using the mean of Brzycki and Mayhew et al. formulas.
         * @param {number} weight The weight lifted.
         * @param {number} reps The number of repetitions.
         * @returns {number} The estimated 1RM.
         */
        function calculate1RM(weight, reps) {
            if (reps === 0 || weight === 0) return 0;

            // Brzycki formula
            const brzycki1RM = weight / (1.0278 - (0.0278 * reps));

            // Mayhew et al. formula
            const mayhew1RM = (100 * weight) / (52.2 + (41.9 * Math.exp(-0.055 * reps)));

            // Return the mean of the two formulas
            return (brzycki1RM + mayhew1RM) / 2;
        }

        /**
         * Updates all calculations: tonnage, 1RM, progression delta, and progress bar.
         */
        function updateAllTotals() {
            let totalTonnage = 0;
            let completedSeries = 0;
            const exercises = state.sessions[state.currentSessionIndex]?.exercises || [];
            let totalSeries = exercises.length * 5;

            exercises.forEach((_, idx) => {
                let tonnage = 0;
                let max1RM = 0;
                for(let i = 0; i < 5; i++) {
                    const repsInput = dom.tbody.querySelector(`.reps[data-ex='${idx}'][data-serie='${i}']`);
                    const weightInput = dom.tbody.querySelector(`.weight[data-ex='${idx}'][data-serie='${i}']`);
                    const reps = +repsInput?.value || 0;
                    const weight = +weightInput?.value || 0;
                    
                    if (reps > 0 && weight > 0) {
                        const currentTonnage = reps * weight;
                        tonnage += currentTonnage;

                        const current1RM = calculate1RM(weight, reps);
                        if (current1RM > max1RM) {
                            max1RM = current1RM;
                        }

                        repsInput.classList.add('completed');
                        weightInput.classList.add('completed');
                        completedSeries++;
                    } else {
                        repsInput?.classList.remove('completed');
                        weightInput?.classList.remove('completed');
                    }
                }
  
                const tonnageEl = dom.tbody.querySelector(`#tonnage-${idx}`);
                if(tonnageEl) {
                    tonnageEl.textContent = tonnage.toFixed(0);
                    tonnageEl.classList.toggle('tonnage-high', tonnage > 0);
                }

                const oneRmEl = dom.tbody.querySelector(`#onerm-${idx}`);
                if (oneRmEl) {
                    oneRmEl.textContent = max1RM > 0 ? max1RM.toFixed(1) : '0';
                    oneRmEl.classList.toggle('onerm-high', max1RM > 0);
                }

                totalTonnage += tonnage;
            });
            
            dom.totalTonnageEl.textContent = `${totalTonnage.toFixed(0)} kg`;
            
            const previous = +dom.previousWeekInput.value || 0; // The `+` operator will convert text to number
            const delta = totalTonnage - previous;
            // Add the +/- sign based on the delta value
            const deltaSign = delta > 0 ? '+' : '';
            dom.deltaEl.textContent = `${deltaSign}${delta.toFixed(0)} kg`;
            dom.deltaEl.style.color = delta > 0 ? 'var(--success-grad-start)' : delta < 0 ? 'var(--danger-grad-start)' : 'inherit';
            dom.progressFill.style.width = `${totalSeries > 0 ? (completedSeries / totalSeries) * 100 : 0}%`;
            
            saveCurrentState();
        }

        function saveCurrentState() {
            const data = {
                reps: [...dom.tbody.querySelectorAll(".reps")].map(i => i.value),
                weight: [...dom.tbody.querySelectorAll(".weight")].map(i => i.value),
                previousWeek: dom.previousWeekInput.value,
                sessionIndex: state.currentSessionIndex,
                customSessions: state.sessions,
                workoutStartTime: state.workoutStartTime,
                isWorkoutTimerPaused: state.isWorkoutTimerPaused,
                pausedTime: state.pausedTime
            };
            localStorage.setItem('inProgressWorkout', JSON.stringify(data));
        }

        function loadCurrentState() {
            const data = JSON.parse(localStorage.getItem('inProgressWorkout'));
            if (!data) return;
            
            dom.tbody.querySelectorAll(".reps").forEach((input, idx) => input.value = data.reps[idx] || '');
            dom.tbody.querySelectorAll(".weight").forEach((input, idx) => input.value = data.weight[idx] || '');
            dom.previousWeekInput.value = data.previousWeek || "";
            updateAllTotals();
        }

        /**
         * Custom confirmation dialog implementation as window.confirm() is not allowed.
         * @param {string} message - The message to display.
         * @returns {Promise<boolean>} - Resolves to true if confirmed, false otherwise.
         */
        function customConfirm(message) {
            return new Promise(resolve => {
                const modal = document.createElement('div');
                modal.className = 'modal-overlay';
                modal.innerHTML = `
                    <div class="modal-content">
                        <p>${message}</p>
                        <div style="display: flex; justify-content: center; gap: 1rem; margin-top: 1.5rem;">
                            <button class="btn btn-danger" id="confirmNo">Non</button>
                            <button class="btn btn-success" id="confirmYes">Oui</button>
                        </div>
                    </div>
                `;
                document.body.appendChild(modal);

                document.getElementById('confirmYes').onclick = () => {
                    modal.remove();
                    resolve(true);
                };
                document.getElementById('confirmNo').onclick = () => {
                    modal.remove();
                    resolve(false);
                };
            });
        }
        
        function finishAndSaveSession() {
            const totalTonnage = +dom.totalTonnageEl.textContent.replace(' kg', ''); // Remove ' kg' for numerical comparison
            if (totalTonnage === 0) {
                showNotification("Aucune donn√©e √† sauvegarder. La session n'a pas √©t√© enregistr√©e.", "info");
                return; 
            }

            if (!state.isWorkoutTimerPaused) {
                pauseTotalWorkoutTimer();
            }

            const workoutData = {
                id: Date.now(),
                date: new Date().toISOString(),
                sessionName: dom.sessionSelect.selectedOptions[0].text,
                totalTonnage,
                duration: dom.totalTimeEl.textContent,
                exercises: (state.sessions[state.currentSessionIndex]?.exercises || []).map((ex, idx) => ({
                    name: ex.name,
                    rest: ex.rest || "1 min",
                    series: Array.from({length: 5}, (_, i) => ({
                        reps: +dom.tbody.querySelector(`.reps[data-ex='${idx}'][data-serie='${i}']`)?.value || 0,
                        weight: +dom.tbody.querySelector(`.weight[data-ex='${idx}'][data-serie='${i}']`)?.value || 0
                    })).filter(s => s.reps > 0 && s.weight > 0)
                })).filter(ex => ex.series.length > 0)
            };
            const history = getHistory();
            history.push(workoutData);
            localStorage.setItem('workoutHistory', JSON.stringify(history));
            showNotification("S√©ance sauvegard√©e dans l'historique!", "success");
            
            Object.values(state.timers).forEach(timer => {
                if (timer && timer.interval) { 
                    clearInterval(timer.interval);
                }
            });
            state.timers = {};
            if (state.totalWorkoutTimeInterval) {
                clearInterval(state.totalWorkoutTimeInterval);
                state.totalWorkoutTimeInterval = null;
            }
            state.workoutStartTime = null;
            state.isWorkoutTimerPaused = false;
            state.pausedTime = 0;
            dom.toggleWorkoutTimerBtn.textContent = '‚èØÔ∏è Pause';
            localStorage.removeItem('inProgressWorkout');
            createTable();
            dom.totalTimeEl.textContent = "00:00:00";
            dom.totalTonnageEl.textContent = "0 kg"; // Reset with kg
            dom.deltaEl.textContent = "0 kg"; // Reset with kg
            dom.previousWeekInput.value = "";
        }

        function getHistory() { return JSON.parse(localStorage.getItem('workoutHistory')) || []; }
        
        function displayHistory() {
            dom.historyList.innerHTML = '';
            getHistory().sort((a, b) => b.id - a.id).forEach(session => {
                const item = document.createElement('div');
                item.className = 'history-item';
                item.innerHTML = `
                    <div>
                        ${new Date(session.date).toLocaleDateString('fr-FR')} - 
                        <strong>${session.sessionName}</strong> (${session.totalTonnage} kg)
                        ${session.duration ? ` - ‚è±Ô∏è ${session.duration}` : ''}
                    </div>
                    <div>
                        <button class="btn btn-primary" data-history-action="details" data-history-id="${session.id}">D√©tails</button>
                        <button class="btn btn-success" data-history-action="load" data-history-id="${session.id}">Utiliser</button>
                        <button class="btn btn-danger" data-history-action="delete" data-history-id="${session.id}">Suppr.</button>
                    </div>
                    <div class="history-details" id="details-${session.id}"></div>`;
                dom.historyList.appendChild(item);
            });
        }
        
        function showHistoryDetails(id) {
            const detailsDiv = document.getElementById(`details-${id}`);
            detailsDiv.classList.toggle('visible');

            if (detailsDiv.classList.contains('visible')) {
                const session = getHistory().find(s => s.id === id);
                if (session) {
                    let detailsHtml = `<h4>D√©tails des exercices:</h4>
                                       <p><strong>Tonnage Total de la S√©ance:</strong> ${session.totalTonnage} kg</p><ul>`;
                    session.exercises.forEach(ex => {
                        let exerciseMax1RM = 0; // Initialize for each exercise
                        ex.series.forEach((s) => { 
                             const oneRM = calculate1RM(s.weight, s.reps);
                             if (oneRM > exerciseMax1RM) {
                                 exerciseMax1RM = oneRM; // Corrected assignment
                             }
                        });
                        detailsHtml += `<li><strong>${ex.name}</strong> (<strong>1RM: ${exerciseMax1RM.toFixed(1)} kg</strong>)</li>`;
                    });
                    detailsHtml += '</ul>';
                    detailsDiv.innerHTML = detailsHtml;
                }
            } else {
                detailsDiv.innerHTML = '';
            }
        }

        function exportCSV() {
            let csv = "DateSession;NomSeance;TonnageTotalSeance;DureeTotaleSeance;Exercice;Serie;Reps;Poids;Tonnage\n";
            const history = getHistory(); // Get all saved sessions

            if (history.length === 0) {
                 showNotification("Aucune donn√©e d'historique √† exporter.", "info");
                 return;
            }

            history.forEach(session => {
                const sessionDate = new Date(session.date);
                // Format date to JJ/MM/AAAA
                const formattedDate = sessionDate.toLocaleDateString('fr-FR', { day: '2-digit', month: '2-digit', year: 'numeric' });
                // Format time to HH AM/PM (e.g., 03 AM, 05 PM)
                const formattedTime = sessionDate.toLocaleTimeString('en-US', { hour: '2-digit', hourCycle: 'h12' }).replace(/:00$/, ''); // Remove :00 for minutes/seconds
                const dateTimeString = `${formattedDate} ${formattedTime}`;

                const sessionName = `"${session.sessionName.replace(/"/g, '""')}"`; // Quote and escape internal quotes
                const totalTonnage = session.totalTonnage.toFixed(0);
                const duration = session.duration; // Already in HH:MM:SS format

                session.exercises.forEach(ex => {
                    const exerciseName = `"${ex.name.replace(/"/g, '""')}"`; // Quote and escape internal quotes
                    ex.series.forEach((serieData, i) => { // Iterate only through recorded series
                        const reps = serieData.reps;
                        // Format weight to use comma as decimal separator for French Excel compatibility
                        const weight = String(serieData.weight).replace('.', ',');
                        const tonnage = (reps * serieData.weight).toFixed(0); // Recalculate tonnage for consistency
                        csv += `${dateTimeString};${sessionName};${totalTonnage};${duration};${exerciseName};${i+1};${reps};${weight};${tonnage}\n`;
                    });
                });
            });

            const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement("a");
            link.href = URL.createObjectURL(blob);
            link.download = `historique_seances_${new Date().toISOString().split('T')[0]}.csv`; // Change filename for history export
            link.click();
            URL.revokeObjectURL(link.href);
            showNotification("Export de l'historique CSV r√©ussi !", "success");
        }
        
        // --- UTILITY & UI FUNCTIONS ---
        function showNotification(message, type = 'info', duration = 5000) { /* duration is now 5 seconds */
            const notification = document.createElement('div');
            notification.className = `notification ${type}`;
            notification.textContent = message;
            dom.notificationContainer.appendChild(notification);
            void notification.offsetWidth;
            notification.classList.add('show');
            setTimeout(() => {
                notification.classList.remove('show');
                notification.addEventListener('transitionend', () => notification.remove(), { once : true });
            }, duration);
        }

        function formatTime(seconds) {
            const h = Math.floor(seconds / 3600);
            const m = Math.floor((seconds % 3600) / 60);
            const s = Math.floor(seconds % 60);
            return `${String(h).padStart(2,'0')}:${String(m).padStart(2,'0')}:${String(s).padStart(2,'0')}`;
        }
        
        function formatTimerDisplay(seconds) {
             const m = Math.floor(seconds / 60);
             const s = Math.floor(seconds % 60);
             return `${m}:${String(s).padStart(2, '0')}`;
        }

        function updateTotalTimeDisplay() {
            if (!state.workoutStartTime) {
                dom.totalTimeEl.textContent = "00:00:00";
                return;
            }
            if (state.isWorkoutTimerPaused) {
                dom.totalTimeEl.textContent = formatTime(state.pausedTime);
            } else {
                const elapsedMilliseconds = Date.now() - new Date(state.workoutStartTime).getTime();
                dom.totalTimeEl.textContent = formatTime(elapsedMilliseconds / 1000);
            }
        }

        /**
         * Starts or resumes the total workout timer.
         */
        function startTotalWorkoutTimer() {
            if (state.totalWorkoutTimeInterval) {
                clearInterval(state.totalWorkoutTimeInterval);
            }
            if (state.isWorkoutTimerPaused) {
                state.workoutStartTime = new Date(Date.now() - state.pausedTime * 1000).toISOString();
                state.isWorkoutTimerPaused = false;
            }
            state.totalWorkoutTimeInterval = setInterval(updateTotalTimeDisplay, 1000);
            updateTotalTimeDisplay();
            dom.toggleWorkoutTimerBtn.textContent = '‚è∏Ô∏è Pause';
            saveCurrentState();
        }

        /**
         * Pauses the total workout timer.
         */
        function pauseTotalWorkoutTimer() {
            if (state.totalWorkoutTimeInterval) {
                clearInterval(state.totalWorkoutTimeInterval);
                state.totalWorkoutTimeInterval = null;
            }
            if (state.workoutStartTime) {
                state.pausedTime = (Date.now() - new Date(state.workoutStartTime).getTime()) / 1000;
            }
            state.isWorkoutTimerPaused = true;
            dom.toggleWorkoutTimerBtn.textContent = '‚ñ∂Ô∏è Play';
            updateTotalTimeDisplay();
            saveCurrentState();
        }
        
        function applyTheme(theme) {
            if (theme === 'dark') {
                dom.body.classList.add('dark-mode');
                dom.themeToggleBtn.textContent = '‚òÄÔ∏è';
            } else {
                dom.body.classList.remove('dark-mode');
                dom.themeToggleBtn.textContent = 'üåô';
            }
        }

        /**
         * Updates the session select dropdown with current sessions.
         * Call this after adding/removing sessions.
         */
        function updateSessionSelectOptions() {
            dom.sessionSelect.innerHTML = '';
            state.sessions.forEach((session, index) => {
                const option = document.createElement('option');
                option.value = index;
                option.textContent = session.name; 
                dom.sessionSelect.appendChild(option);
            });
        }

        // Functions for new session modal
        function showNewSessionModal() {
            dom.newSessionModal.classList.remove('hidden');
            dom.newSessionNameInput.value = '';
            dom.newSessionNameInput.focus();
        }

        function hideNewSessionModal() {
            dom.newSessionModal.classList.add('hidden');
        }

        async function createNewSession() {
            const newName = dom.newSessionNameInput.value.trim();
            if (!newName) {
                showNotification("Veuillez donner un nom √† la nouvelle s√©ance.", "error");
                return;
            }

            const isDuplicate = state.sessions.some(s => s.name.toLowerCase() === newName.toLowerCase());
            if (isDuplicate) {
                showNotification(`Une s√©ance nomm√©e "${newName}" existe d√©j√†.`, "error");
                return;
            }

            const newSession = { name: newName, exercises: [] };
            state.sessions.push(newSession);

            updateSessionSelectOptions();
            state.currentSessionIndex = state.sessions.length - 1;
            dom.sessionSelect.value = state.currentSessionIndex;

            localStorage.removeItem('inProgressWorkout');
            state.workoutStartTime = null;
            state.isWorkoutTimerPaused = false;
            state.pausedTime = 0;
            dom.totalTimeEl.textContent = "00:00:00";
            dom.toggleWorkoutTimerBtn.textContent = '‚ñ∂Ô∏è Play';

            createTable();
            updateAllTotals();

            showNotification(`S√©ance "${newName}" cr√©√©e avec succ√®s !`, "success");
            hideNewSessionModal();
        }

        /**
         * Logic to open a historical session in a new, current session.
         * @param {object} historicalSession - The session object from history.
         */
        async function openNewSessionLogic(historicalSession) {
            const confirmed = await customConfirm("Voulez-vous ouvrir cette s√©ance ? La s√©ance en cours sera remplac√©e.");
            if (!confirmed) {
                return;
            }

            // Clear current in-progress state
            Object.values(state.timers).forEach(timer => {
                if (timer && timer.interval) clearInterval(timer.interval);
            });
            state.timers = {};
            if (state.totalWorkoutTimeInterval) {
                clearInterval(state.totalWorkoutTimeInterval);
                state.totalWorkoutTimeInterval = null;
            }
            state.workoutStartTime = null;
            state.isWorkoutTimerPaused = false;
            state.pausedTime = 0;
            dom.toggleWorkoutTimerBtn.textContent = '‚ñ∂Ô∏è Play';
            localStorage.removeItem('inProgressWorkout');
            dom.totalTimeEl.textContent = "00:00:00";
            dom.totalTonnageEl.textContent = "0 kg"; // Reset with kg
            dom.deltaEl.textContent = "0 kg"; // Reset with kg
            dom.previousWeekInput.value = "";

            let sessionIndexToLoad = state.sessions.findIndex(s => s.name === historicalSession.sessionName);
            
            if (sessionIndexToLoad === -1) {
                // If session name doesn't exist, create a new session template
                const newTemplateExercises = historicalSession.exercises.map(ex => ({
                    name: ex.name,
                    rest: ex.rest || "1 min" // Ensure rest is present
                }));
                const newTemplate = { name: historicalSession.sessionName, exercises: newTemplateExercises };
                state.sessions.push(newTemplate);
                sessionIndexToLoad = state.sessions.length - 1;
                updateSessionSelectOptions(); // Update dropdown with new session
            } else {
                // If session name exists, update its exercises based on historical data
                state.sessions[sessionIndexToLoad].exercises = historicalSession.exercises.map(ex => ({
                    name: ex.name,
                    rest: ex.rest || "1 min"
                }));
            }

            state.currentSessionIndex = sessionIndexToLoad;
            dom.sessionSelect.value = state.currentSessionIndex; // Select the newly loaded session
            
            createTable(); // Recreate table for the new session structure

            // Populate the input fields with historical data
            historicalSession.exercises.forEach((historicalEx, exIdx) => {
                // Find the corresponding row in the newly created table
                const exerciseRows = dom.tbody.querySelectorAll('.exercise-row');
                let targetExRow = null;
                // Find by name in case order changed
                for (let j = 0; j < exerciseRows.length; j++) {
                    if (exerciseRows[j].querySelector('.fixed-col').textContent.trim() === historicalEx.name) {
                        targetExRow = exerciseRows[j];
                        break;
                    }
                }

                if (targetExRow) {
                    historicalEx.series.forEach((serieData, serieIdx) => {
                        const repsInput = targetExRow.querySelector(`.reps[data-serie='${serieIdx}']`);
                        const weightInput = targetExRow.querySelector(`.weight[data-serie='${serieIdx}']`);
                        if (repsInput && weightInput) {
                            repsInput.value = serieData.reps;
                            weightInput.value = serieData.weight;
                            if (serieData.reps > 0 && serieData.weight > 0) {
                                repsInput.classList.add('completed');
                                weightInput.classList.add('completed');
                            }
                        }
                    });
                }
            });

            updateAllTotals(); // Final update to reflect loaded data
            showNotification(`S√©ance "${historicalSession.sessionName}" ouverte.`, "success", 3000);
            dom.loadOptionsModal.classList.add('hidden'); // Hide the options modal
            dom.historyModal.classList.add('hidden'); // Hide history modal
        }

        /**
         * Logic to append/update exercises from a historical session to the current session.
         * @param {object} historicalSession - The session object from history.
         */
        async function appendToCurrentSessionLogic(historicalSession) {
            const confirmed = await customConfirm("Voulez-vous ajouter/mettre √† jour les exercices de cette s√©ance √† la s√©ance en cours ?");
            if (!confirmed) {
                return;
            }

            const currentSession = state.sessions[state.currentSessionIndex];
            if (!currentSession.exercises) {
                currentSession.exercises = []; // Ensure exercises array exists
            }

            let exercisesAdded = 0;
            let exercisesUpdated = 0;

            historicalSession.exercises.forEach(historicalEx => {
                const existingExIndex = currentSession.exercises.findIndex(ex => ex.name === historicalEx.name);

                if (existingExIndex !== -1) {
                    // Exercise exists, update its series data
                    const currentEx = currentSession.exercises[existingExIndex];
                    // Ensure currentEx.series is an array before iterating
                    if (!Array.isArray(currentEx.series)) {
                        currentEx.series = Array(5).fill(null).map(() => ({ reps: 0, weight: 0 })); // Initialize with default series
                    }
                    historicalEx.series.forEach((historicalSerie, i) => { 
                        // Only update if historical series has data (reps or weight > 0)
                        if (historicalSerie && (historicalSerie.reps > 0 || historicalSerie.weight > 0)) { 
                            // Ensure the target series slot exists and is an object
                            if (!currentEx.series[i]) {
                                currentEx.series[i] = { reps: 0, weight: 0 };
                            }
                            currentEx.series[i].reps = historicalSerie.reps;
                            currentEx.series[i].weight = historicalSerie.weight;
                        }
                    });
                    exercisesUpdated++;
                } else {
                    // Exercise does not exist, add it
                    // Create a deep copy of the historical exercise to avoid reference issues
                    currentSession.exercises.push(JSON.parse(JSON.stringify(historicalEx)));
                    exercisesAdded++;
                }
            });

            createTable(); // Recreate table to reflect new/updated exercises

            // Re-populate inputs based on the updated state.sessions
            // This is crucial because createTable only builds the structure,
            // we need to fill the values from the modified state.sessions data.
            currentSession.exercises.forEach((currentEx, exIdx) => {
                const tableRow = dom.tbody.querySelector(`.exercise-row[data-exercise-index="${exIdx}"]`);
                if (tableRow) {
                    // Ensure currentEx.series is an array before iterating
                    if (!Array.isArray(currentEx.series)) {
                         currentEx.series = Array(5).fill(null).map(() => ({ reps: 0, weight: 0 }));
                    }
                    currentEx.series.forEach((serieData, serieIdx) => {
                        const repsInput = tableRow.querySelector(`.reps[data-serie='${serieIdx}']`);
                        const weightInput = tableRow.querySelector(`.weight[data-serie='${serieIdx}']`);
                        if (repsInput && weightInput && serieData) { // Check serieData is not null
                            repsInput.value = serieData.reps;
                            weightInput.value = serieData.weight;
                            if (serieData.reps > 0 && serieData.weight > 0) {
                                repsInput.classList.add('completed');
                                weightInput.classList.add('completed');
                            }
                        }
                    });
                }
            });

            updateAllTotals(); // Recalculate totals based on the merged data
            showNotification(`Exercices ${exercisesAdded} ajout√©s et ${exercisesUpdated} mis √† jour dans la s√©ance actuelle.`, "success", 5000);
            dom.loadOptionsModal.classList.add('hidden'); // Hide the options modal
            dom.historyModal.classList.add('hidden'); // Hide history modal
        }

        // Function to show the load options modal
        function showLoadOptionsModal(session) {
            state.sessionToLoad = session; // Store the session temporarily
            dom.loadSessionNameDisplay.textContent = session.sessionName;
            dom.loadOptionsModal.classList.remove('hidden');
        }

        // Function to hide the load options modal
        function hideLoadOptionsModal() {
            dom.loadOptionsModal.classList.add('hidden');
            state.sessionToLoad = null; // Clear the stored session
        }

        // --- EVENT LISTENERS ---
        function setupEventListeners() {
            dom.sessionSelect.addEventListener('change', async () => {
                const lastSavedIndex = state.currentSessionIndex;
                if (localStorage.getItem('inProgressWorkout')) {
                    const confirmed = await customConfirm("Changer de s√©ance annulera la s√©ance en cours. Continuer ?");
                    if (!confirmed) {
                        dom.sessionSelect.value = lastSavedIndex;
                        return;
                    }
                    Object.values(state.timers).forEach(timer => clearInterval(timer.interval));
                    state.timers = {};
                    if (state.totalWorkoutTimeInterval) {
                        clearInterval(state.totalWorkoutTimeInterval);
                        state.totalWorkoutTimeInterval = null;
                    }
                    state.workoutStartTime = null;
                    state.isWorkoutTimerPaused = false;
                    state.pausedTime = 0;
                    dom.toggleWorkoutTimerBtn.textContent = '‚èØÔ∏è Pause';
                    localStorage.removeItem('inProgressWorkout');
                    dom.totalTimeEl.textContent = "00:00:00";
                    dom.totalTonnageEl.textContent = "0 kg"; // Reset with kg
                    dom.deltaEl.textContent = "0 kg"; // Reset with kg
                    dom.previousWeekInput.value = "";
                }
                state.currentSessionIndex = +dom.sessionSelect.value;
                createTable();
            });
            
            document.getElementById('addExerciseBtn').addEventListener('click', () => {
                const name = dom.customExerciseInput.value.trim();
                if (name) {
                    if (!state.sessions[state.currentSessionIndex].exercises) {
                        state.sessions[state.currentSessionIndex].exercises = [];
                    }
                    state.sessions[state.currentSessionIndex].exercises.push({ name, rest: "1 min" });
                    createTable();
                    dom.customExerciseInput.value = '';
                    showNotification(`Exercice "${name}" ajout√©.`, "info");
                } else {
                    showNotification("Veuillez entrer un nom d'exercice.", "error");
                }
            });

            dom.tbody.addEventListener('change', e => {
                if (e.target.classList.contains('reps') || e.target.classList.contains('weight')) {
                    if (!state.workoutStartTime && !state.isWorkoutTimerPaused) {
                        state.workoutStartTime = new Date().toISOString();
                        startTotalWorkoutTimer();
                    }
                    
                    const exIndex = e.target.dataset.ex;
                    const serieIndex = parseInt(e.target.dataset.serie, 10);
                    
                    const repsInput = dom.tbody.querySelector(`.reps[data-ex='${exIndex}'][data-serie='${serieIndex}']`);
                    const weightInput = dom.tbody.querySelector(`.weight[data-ex='${exIndex}'][data-serie='${serieIndex}']`);
                    
                    if (repsInput.value > 0 && weightInput.value > 0 && serieIndex < 4) {
                        const nextWeightInput = dom.tbody.querySelector(`.weight[data-ex='${exIndex}'][data-serie='${serieIndex + 1}']`);
                        if (nextWeightInput && !nextWeightInput.value) {
                            nextWeightInput.value = weightInput.value;
                        }
                    }

                    updateAllTotals();
                } 
            });

            // The 'input' event listener for previousWeek is still needed for calculation
            dom.previousWeekInput.addEventListener('input', updateAllTotals); 

            dom.tbody.addEventListener('click', handleTableActions);
            document.getElementById('finishSessionBtn').addEventListener('click', finishAndSaveSession);
            document.getElementById('viewHistoryBtn').addEventListener('click', () => {
                displayHistory();
                dom.historyModal.classList.remove('hidden');
            });
            dom.historyModal.addEventListener('click', handleHistoryActions);
            document.getElementById('exportBtn').addEventListener('click', exportCSV);
            dom.importFileInput.addEventListener('change', (event) => { 
                const file = event.target.files[0];
                if (!file) {
                    showNotification("Aucun fichier s√©lectionn√©.", "info");
                    return;
                }

                const reader = new FileReader();
                reader.onload = async (e) => {
                    try {
                        const content = e.target.result;
                        let importedDataAddedToHistory = false;

                        if (file.type === 'application/json') {
                            const importedHistory = JSON.parse(content);
                            
                            // More robust validation for the deep structure
                            const hasValidWorkoutStructure = Array.isArray(importedHistory) && importedHistory.every(session => {
                                // Check top-level properties
                                if (!session.sessionName || typeof session.totalTonnage === 'undefined' || typeof session.duration === 'undefined' || !Array.isArray(session.exercises)) {
                                    return false;
                                }
                                // Check exercises array and its properties
                                return session.exercises.every(exercise => {
                                    if (!exercise.name || typeof exercise.rest === 'undefined' || !Array.isArray(exercise.series)) {
                                        return false;
                                    }
                                    // Check series array and its properties
                                    return serie.reps !== undefined && serie.weight !== undefined && typeof serie.reps === 'number' && typeof serie.weight === 'number';
                                });
                            });

                            if (!hasValidWorkoutStructure) {
                                showNotification("Le fichier JSON import√© ne correspond pas au format attendu pour les donn√©es d'entra√Ænement. Veuillez v√©rifier sa structure.", "error", 5000);
                                console.error("Imported JSON has invalid deep structure:", importedHistory);
                                return; // Stop execution if structure is invalid
                            }

                            const confirmed = await customConfirm("Importer l'historique ? Cela remplacera l'historique actuel.");
                            if (confirmed) {
                                localStorage.setItem('workoutHistory', JSON.stringify(importedHistory));
                                importedDataAddedToHistory = true;
                                displayHistory(); // Refresh history list
                            } else {
                                showNotification("Importation annul√©e.", "info");
                            }
                        } else if (file.type === 'text/csv') {
                            const lines = content.split('\n').filter(line => line.trim() !== '');
                            if (lines.length <= 1) { // Only header or empty
                                showNotification("Le fichier CSV est vide ou ne contient pas de donn√©es.", "error");
                                return;
                            }

                            const importedExercisesMap = new Map(); // Map to store exercises: ExerciseName -> { name, rest, series: [{reps, weight}, ...] }

                            const expectedHeaderWithTonnage = "Exercice;Serie;Reps;Poids;Tonnage";
                            const expectedHeaderWithoutTonnage = "Exercice;Serie;Reps;Poids";
                            const actualHeader = lines[0].trim();

                            let hasTonnageColumn = false;
                            let expectedPartsLength = 0;

                            if (actualHeader === expectedHeaderWithTonnage) {
                                hasTonnageColumn = true;
                                expectedPartsLength = 5;
                            } else if (actualHeader === expectedHeaderWithoutTonnage) {
                                hasTonnageColumn = false;
                                expectedPartsLength = 4;
                            } else {
                                showNotification(`En-t√™te CSV inattendu. Attendu: "${expectedHeaderWithTonnage}" ou "${expectedHeaderWithoutTonnage}". Votre fichier a: "${actualHeader}".`, "error", 7000);
                                return;
                            }

                            for (let i = 1; i < lines.length; i++) { // Start from second line to skip header
                                const line = lines[i].trim();
                                if (!line) continue;

                                const parts = line.split(';');
                                
                                if (parts.length !== expectedPartsLength) {
                                    showNotification(`Ligne CSV invalide: "${line}". Nombre de colonnes inattendu pour l'en-t√™te d√©tect√©.`, "warning", 7000);
                                    continue;
                                }

                                const exerciseName = parts[0].replace(/"/g, '').trim(); // Remove quotes around exercise name
                                const serieIndex = parseInt(parts[1], 10) - 1; // Convert to 0-indexed
                                const reps = parseInt(parts[2], 10);
                                // For import, we need to convert comma back to period for parseFloat
                                const weight = parseFloat(parts[3].replace(',', '.'));
                                // Tonnage (parts[4]) is ignored as it's a calculated field, it's only present if hasTonnageColumn is true

                                if (isNaN(serieIndex) || serieIndex < 0 || serieIndex >= 5 || isNaN(reps) || isNaN(weight)) {
                                    showNotification(`Donn√©es num√©riques invalides dans la ligne CSV: "${line}".`, "warning", 7000);
                                    continue;
                                }

                                if (!importedExercisesMap.has(exerciseName)) {
                                    importedExercisesMap.set(exerciseName, {
                                        name: exerciseName,
                                        rest: "1 min", // Default rest time, as it's not in the export CSV
                                        series: Array(5).fill(null).map(() => ({ reps: 0, weight: 0 })) // Initialize 5 series with 0s
                                    });
                                }
                                const exerciseData = importedExercisesMap.get(exerciseName);
                                // Deep copy the series data to ensure independent objects
                                if (!exerciseData.series[serieIndex]) {
                                    exerciseData.series[serieIndex] = {};
                                }
                                exerciseData.series[serieIndex].reps = reps;
                                exerciseData.series[serieIndex].weight = weight;
                            }

                            const importedExercisesForNewSession = Array.from(importedExercisesMap.values());
                            
                            if (importedExercisesForNewSession.length > 0) {
                                const newSessionName = `Import CSV - ${new Date().toLocaleDateString('fr-FR')}`;
                                // Calculate total tonnage for the imported session
                                const totalTonnageImported = importedExercisesForNewSession.reduce((accEx, ex) => {
                                    return accEx + ex.series.reduce((accSerie, serie) => {
                                        return accSerie + (serie?.reps || 0) * (serie?.weight || 0);
                                    }, 0);
                                }, 0);

                                const importedSessionAsHistoryItem = {
                                    id: Date.now(),
                                    date: new Date().toISOString(),
                                    sessionName: newSessionName,
                                    totalTonnage: totalTonnageImported,
                                    duration: "00:00:00", // Duration not available from CSV, set to default
                                    exercises: importedExercisesForNewSession
                                };
                                const history = getHistory();
                                history.push(importedSessionAsHistoryItem);
                                localStorage.setItem('workoutHistory', JSON.stringify(history));
                                importedDataAddedToHistory = true;
                                displayHistory(); // Refresh history list

                                // Add the imported session as a new session type if it doesn't exist
                                const existingSessionIndex = state.sessions.findIndex(s => s.name === newSessionName);
                                if (existingSessionIndex === -1) {
                                    state.sessions.push({ name: newSessionName, exercises: importedExercisesForNewSession });
                                    updateSessionSelectOptions();
                                }
                            } else {
                                showNotification("Aucune donn√©e valide trouv√©e dans le fichier CSV pour l'importation.", "info", 5000);
                            }
                        } else {
                            showNotification("Type de fichier non pris en charge. Veuillez importer un fichier JSON ou CSV.", "error");
                        }
                        
                        if (importedDataAddedToHistory) {
                            showNotification("S√©ance(s) import√©e(s) √† l'historique. Utilisez l'option 'Historique' pour les charger.", "success", 5000);
                        }

                    } catch (error) {
                        console.error("Erreur lors de la lecture ou du parsing du fichier:", error);
                        showNotification("Erreur lors de la lecture ou du parsing du fichier. Assurez-vous qu'il est valide.", "error");
                    } finally {
                        dom.importFileInput.value = ''; // Clear the file input
                    }
                }; 
                reader.onerror = (error) => {
                    console.error("FileReader error:", error);
                    showNotification("Erreur lors de la lecture du fichier.", "error");
                };
                reader.readAsText(file);
            });
            document.getElementById('importBtn').addEventListener('click', () => dom.importFileInput.click()); // Moved here
            document.getElementById('closeHistoryModal').addEventListener('click', () => dom.historyModal.classList.add('hidden'));
            dom.themeToggleBtn.addEventListener('click', () => {
                const newTheme = dom.body.classList.contains('dark-mode') ? 'light' : 'dark';
                applyTheme(newTheme);
                localStorage.setItem('theme', newTheme); // Persist user's manual preference
            });
            dom.toggleWorkoutTimerBtn.addEventListener('click', () => {
                if (state.workoutStartTime) {
                    if (state.isWorkoutTimerPaused) {
                        startTotalWorkoutTimer();
                    } else {
                        pauseTotalWorkoutTimer();
                    }
                } else {
                    showNotification("Commencez la s√©ance en entrant des donn√©es pour d√©marrer le minuteur.", "info");
                }
            });

            // Event listeners for the new session modal
            dom.createNewSessionTypeBtn.addEventListener('click', showNewSessionModal);
            dom.closeNewSessionModal.addEventListener('click', hideNewSessionModal);
            dom.cancelNewSessionBtn.addEventListener('click', hideNewSessionModal);
            dom.createNewSessionBtn.addEventListener('click', createNewSession);

            // Event listeners for the load options modal
            dom.closeLoadOptionsModal.addEventListener('click', hideLoadOptionsModal);
            dom.openNewSessionBtn.addEventListener('click', () => {
                if (state.sessionToLoad) {
                    openNewSessionLogic(state.sessionToLoad);
                }
            });
            dom.appendToCurrentSessionBtn.addEventListener('click', () => {
                if (state.sessionToLoad) {
                    appendToCurrentSessionLogic(state.sessionToLoad);
                }
            });

            document.addEventListener('keydown', e => {
                if (e.ctrlKey || e.metaKey) {
                    if (e.key === 's') { e.preventDefault(); finishAndSaveSession(); }
                    if (e.key === 'e') { e.preventDefault(); exportCSV(); }
                }
                if (e.key === 'Escape') {
                    if (!dom.historyModal.classList.contains('hidden')) {
                        dom.historyModal.classList.add('hidden');
                    }
                    if (!dom.newSessionModal.classList.contains('hidden')) {
                        dom.newSessionModal.classList.add('hidden');
                    }
                    if (!dom.loadOptionsModal.classList.contains('hidden')) {
                        hideLoadOptionsModal();
                    }
                }
            });
        }
        
        async function handleTableActions(e) {
            const button = e.target.closest('button');
            if (!button) return;
            const row = button.closest('.exercise-row');
            const idx = +row.dataset.exerciseIndex;
            const timerAction = button.dataset.timerAction;
            const action = button.dataset.action;
            if (timerAction) handleTimerActions(timerAction, idx, row);
            else if (action === 'remove') {
                const confirmed = await customConfirm(`Supprimer "${state.sessions[state.currentSessionIndex].exercises[idx].name}" ?`);
                if (confirmed) {
                    state.sessions[state.currentSessionIndex].exercises.splice(idx, 1);
                    if (state.timers[idx]) {
                        clearInterval(state.timers[idx].interval);
                        delete state.timers[idx];
                    }
                    createTable();
                    showNotification(`Exercice supprim√©.`, "info");
                }
            }
        }
        
        function handleTimerActions(timerAction, idx, row) {
             const timerDisplay = row.querySelector('.timer-display');
             const restString = state.sessions[state.currentSessionIndex].exercises[idx].rest;
            let restSeconds = parseInt(restString) * (restString.includes('min') ? 60 : 1) || 60;
            const duration = Math.max(restSeconds, 60);

            if (timerAction === 'start') {
                if (state.timers[idx] && state.timers[idx].interval) clearInterval(state.timers[idx].interval);
                state.timers[idx] = {
                    secondsElapsed: 0,
                    duration: duration,
                    interval: setInterval(() => {
                        state.timers[idx].secondsElapsed++;
                        const remaining = state.timers[idx].duration - state.timers[idx].secondsElapsed;
                        if (remaining <= 0) {
                            timerDisplay.textContent = "0:00";
                            timerDisplay.classList.remove('timer-active');
                            clearInterval(state.timers[idx].interval);
                            showNotification(`Repos termin√© pour ${state.sessions[state.currentSessionIndex].exercises[idx].name}!`, "info");
                            row.querySelector('[data-timer-action="start"]').classList.remove('hidden');
                            row.querySelector('[data-timer-action="stop"]').classList.add('hidden');
                        } else {
                            timerDisplay.textContent = formatTimerDisplay(remaining);
                        }
                    }, 1000)
                };
                timerDisplay.textContent = formatTimerDisplay(duration);
                timerDisplay.classList.add('timer-active');
                row.querySelector('[data-timer-action="start"]').classList.add('hidden');
                row.querySelector('[data-timer-action="stop"]').classList.add('hidden'); /* Changed to add hidden */

            } else if (timerAction === 'stop' || timerAction === 'reset') {
                if (state.timers[idx] && state.timers[idx].interval) clearInterval(state.timers[idx].interval);
                state.timers[idx] = null;
                timerDisplay.classList.remove('timer-active');
                timerDisplay.textContent = formatTimerDisplay(duration);
                row.querySelector('[data-timer-action="start"]').classList.remove('hidden');
                row.querySelector('[data-timer-action="stop"]').classList.add('hidden');
            }
        }

        async function handleHistoryActions(e) {
            const button = e.target.closest('button');
            if (!button) return;
            const historyAction = button.dataset.historyAction;
            const historyId = +button.dataset.historyId;
            if (historyAction === 'details') showHistoryDetails(historyId);
            else if (historyAction === 'delete') await deleteHistoryItem(historyId);
            else if (historyAction === 'load') {
                const historicalSession = getHistory().find(s => s.id === historyId);
                if (historicalSession) {
                    showLoadOptionsModal(historicalSession); // Show options modal instead of direct load
                } else {
                    showNotification("S√©ance historique introuvable.", "error");
                }
            }
        }

        async function deleteHistoryItem(id) {
            const confirmed = await customConfirm("Voulez-vous vraiment supprimer cette s√©ance de l'historique ?");
            if (confirmed) {
                let history = getHistory().filter(session => session.id !== id);
                localStorage.setItem('workoutHistory', JSON.stringify(history));
                displayHistory();
                showNotification("S√©ance supprim√©e de l'historique.", "info");
            }
        }

        // --- INITIALIZATION ---
        function init() {
            const savedTheme = localStorage.getItem('theme'); // Retrieve saved theme if any

            if (savedTheme) {
                // If a theme is explicitly saved by the user, use it
                applyTheme(savedTheme);
            } else {
                // If no theme is saved, use the system's preferred color scheme
                const prefersDark = window.matchMedia('(prefers-color-scheme: dark)');
                applyTheme(prefersDark.matches ? 'dark' : 'light');

                // Add a listener for changes in system preference, but only if no user preference is set
                prefersDark.addEventListener('change', (e) => {
                    // Re-check localStorage in case user manually set a theme since the listener was added
                    if (!localStorage.getItem('theme')) {
                        applyTheme(e.matches ? 'dark' : 'light');
                    }
                });
            }

            const inProgress = JSON.parse(localStorage.getItem('inProgressWorkout'));
            if (inProgress?.customSessions) {
                state.sessions = inProgress.customSessions;
            } else {
                state.sessions = JSON.parse(JSON.stringify(defaultSessions)); 
            }
            state.currentSessionIndex = inProgress?.sessionIndex || 0;
            if (state.currentSessionIndex >= state.sessions.length) {
                state.currentSessionIndex = 0;
            }

            state.workoutStartTime = inProgress?.workoutStartTime || null;
            state.isWorkoutTimerPaused = inProgress?.isWorkoutTimerPaused || false;
            state.pausedTime = inProgress?.pausedTime || 0;
            
            updateSessionSelectOptions();
            dom.sessionSelect.value = state.currentSessionIndex;

            setupEventListeners();
            createTable();

            // Initial display of totals with "kg" and progression sign
            updateAllTotals();

            if (state.workoutStartTime && !state.isWorkoutTimerPaused) {
                startTotalWorkoutTimer();
            } else if (state.workoutStartTime && state.isWorkoutTimerPaused) {
                dom.totalTimeEl.textContent = formatTime(state.pausedTime);
                dom.toggleWorkoutTimerBtn.textContent = '‚ñ∂Ô∏è Play';
            } else {
                dom.totalTimeEl.textContent = "00:00:00";
                dom.toggleWorkoutTimerBtn.textContent = '‚ñ∂Ô∏è Play';
            }
        }

        init();
    });
    </script>
</body>
</html>